[{"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [{"name": "Builtin_BFloat16", "cppName": "::mlir::FloatType", "numParameters": 0, "dialect": "builtin", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Builtin_Complex", "cppName": "::mlir::Type", "numParameters": 1, "dialect": "builtin", "parameters": [{"name": "elementType", "cppType": "Type"}], "hasVerifier": true, "traits": [], "interfaces": []}, {"name": "Builtin_Float128", "cppName": "::mlir::FloatType", "numParameters": 0, "dialect": "builtin", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Builtin_Float16", "cppName": "::mlir::FloatType", "numParameters": 0, "dialect": "builtin", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Builtin_Float32", "cppName": "::mlir::FloatType", "numParameters": 0, "dialect": "builtin", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Builtin_Float64", "cppName": "::mlir::FloatType", "numParameters": 0, "dialect": "builtin", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Builtin_Float80", "cppName": "::mlir::FloatType", "numParameters": 0, "dialect": "builtin", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Builtin_Function", "cppName": "::mlir::Type", "numParameters": 2, "dialect": "builtin", "parameters": [{"name": "inputs", "cppType": "ArrayRef<Type>"}, {"name": "results", "cppType": "ArrayRef<Type>"}], "hasVerifier": false, "traits": [], "interfaces": ["::mlir::SubElementTypeInterface::Trait"]}, {"name": "Builtin_Index", "cppName": "::mlir::Type", "numParameters": 0, "dialect": "builtin", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Builtin_Integer", "cppName": "::mlir::Type", "numParameters": 2, "dialect": "builtin", "parameters": [{"name": "width", "cppType": "unsigned"}, {"name": "signedness", "cppType": "SignednessSemantics"}], "hasVerifier": true, "traits": [], "interfaces": []}, {"name": "Builtin_MemRef", "cppName": "BaseMemRefType", "numParameters": 4, "dialect": "builtin", "parameters": [{"name": "shape", "cppType": "::llvm::ArrayRef<int64_t>"}, {"name": "elementType", "cppType": "Type"}, {"name": "affineMaps", "cppType": "::llvm::ArrayRef<AffineMap>"}, {"name": "memorySpace", "cppType": "Attribute"}], "hasVerifier": true, "traits": [], "interfaces": ["::mlir::SubElementTypeInterface::Trait"]}, {"name": "Builtin_None", "cppName": "::mlir::Type", "numParameters": 0, "dialect": "builtin", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Builtin_Opaque", "cppName": "::mlir::Type", "numParameters": 2, "dialect": "builtin", "parameters": [{"name": "dialectNamespace", "cppType": "Identifier"}, {"name": "typeData", "cppType": "::llvm::StringRef"}], "hasVerifier": true, "traits": [], "interfaces": []}, {"name": "Builtin_RankedTensor", "cppName": "TensorType", "numParameters": 3, "dialect": "builtin", "parameters": [{"name": "shape", "cppType": "::llvm::ArrayRef<int64_t>"}, {"name": "elementType", "cppType": "Type"}, {"name": "encoding", "cppType": "Attribute"}], "hasVerifier": true, "traits": [], "interfaces": ["::mlir::SubElementTypeInterface::Trait"]}, {"name": "Builtin_Tuple", "cppName": "::mlir::Type", "numParameters": 1, "dialect": "builtin", "parameters": [{"name": "types", "cppType": "ArrayRef<Type>"}], "hasVerifier": false, "traits": [], "interfaces": ["::mlir::SubElementTypeInterface::Trait"]}, {"name": "Builtin_UnrankedMemRef", "cppName": "BaseMemRefType", "numParameters": 2, "dialect": "builtin", "parameters": [{"name": "elementType", "cppType": "Type"}, {"name": "memorySpace", "cppType": "Attribute"}], "hasVerifier": true, "traits": [], "interfaces": ["::mlir::SubElementTypeInterface::Trait"]}, {"name": "Builtin_UnrankedTensor", "cppName": "TensorType", "numParameters": 1, "dialect": "builtin", "parameters": [{"name": "elementType", "cppType": "Type"}], "hasVerifier": true, "traits": [], "interfaces": ["::mlir::SubElementTypeInterface::Trait"]}, {"name": "Builtin_Vector", "cppName": "ShapedType", "numParameters": 2, "dialect": "builtin", "parameters": [{"name": "shape", "cppType": "::llvm::ArrayRef<int64_t>"}, {"name": "elementType", "cppType": "Type"}], "hasVerifier": true, "traits": [], "interfaces": ["::mlir::SubElementTypeInterface::Trait"]}], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": [{"name": "CallSiteLoc", "cppName": "::mlir::LocationAttr", "numParameters": 2, "dialect": "builtin", "parameters": [{"name": "callee", "cppType": "Location"}, {"name": "caller", "cppType": "Location"}], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "FileLineColLoc", "cppName": "::mlir::LocationAttr", "numParameters": 3, "dialect": "builtin", "parameters": [{"name": "filename", "cppType": "Identifier"}, {"name": "line", "cppType": "unsigned"}, {"name": "column", "cppType": "unsigned"}], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "FusedLoc", "cppName": "::mlir::LocationAttr", "numParameters": 2, "dialect": "builtin", "parameters": [{"name": "locations", "cppType": "::llvm::ArrayRef<Location>"}, {"name": "metadata", "cppType": "Attribute"}], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "NameLoc", "cppName": "::mlir::LocationAttr", "numParameters": 2, "dialect": "builtin", "parameters": [{"name": "name", "cppType": "Identifier"}, {"name": "childLoc", "cppType": "Location"}], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "OpaqueLoc", "cppName": "::mlir::LocationAttr", "numParameters": 3, "dialect": "builtin", "parameters": [{"name": "underlyingLocation", "cppType": "uintptr_t"}, {"name": "underlyingTypeID", "cppType": "TypeID"}, {"name": "fallbackLocation", "cppType": "Location"}], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "UnknownLoc", "cppName": "::mlir::LocationAttr", "numParameters": 0, "dialect": "builtin", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}]}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [{"name": "builtin.func", "numResults": 0, "interfaces": ["::mlir::CallableOpInterface::Trait", "::mlir::SymbolOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {"sym_visibility": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "type": {"predicate": "(($_self.isa<::mlir::TypeAttr>())) && (($_self.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypeAttrBase"], "kind": "predicate"}, "sym_name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "builtin", "traits": [{"name": "::mlir::OpTrait::AffineScope", "kind": "native"}, {"name": "::mlir::OpTrait::AutomaticAllocationScope", "kind": "native"}, {"name": "::mlir::OpTrait::FunctionLike", "kind": "native"}, {"name": "::mlir::OpTrait::IsIsolatedFromAbove", "kind": "native"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "builtin.module", "numResults": 0, "interfaces": ["::mlir::SymbolOpInterface::Trait", "::mlir::OpAsmOpInterface::Trait", "::mlir::RegionKindInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 1, "attributes": {"sym_visibility": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "sym_name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "builtin", "traits": [{"name": "::mlir::OpTrait::AffineScope", "kind": "native"}, {"name": "::mlir::OpTrait::IsIsolatedFromAbove", "kind": "native"}, {"name": "::mlir::OpTrait::NoRegionArguments", "kind": "native"}, {"name": "::mlir::OpTrait::SymbolTable", "kind": "native"}, {"name": "::mlir::OpTrait::NoTerminator", "kind": "native"}, {"name": "::mlir::OpTrait::SingleBlock", "kind": "native"}, {"name": "::mlir::OpTrait::HasOnlyGraphRegion", "kind": "native"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "builtin.unrealized_conversion_cast", "numResults": 1, "interfaces": ["::mlir::CastOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "outputs", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "builtin", "traits": [], "hasVerifier": false, "operands": [{"name": "inputs", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": [{"name": "Builtin_AffineMapAttr", "cppName": "::mlir::Attribute", "numParameters": 1, "dialect": "builtin", "parameters": [{"name": "value", "cppType": "AffineMap"}], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Builtin_ArrayAttr", "cppName": "::mlir::Attribute", "numParameters": 1, "dialect": "builtin", "parameters": [{"name": "value", "cppType": "::llvm::ArrayRef<Attribute>"}], "hasVerifier": false, "traits": [], "interfaces": ["::mlir::SubElementAttrInterface::Trait"]}, {"name": "Builtin_DenseIntOrFPElementsAttr", "cppName": "DenseElementsAttr", "numParameters": 2, "dialect": "builtin", "parameters": [{"name": "type", "cppType": "ShapedType"}, {"name": "rawData", "cppType": "ArrayRef<char>"}], "hasVerifier": false, "traits": [], "interfaces": ["::mlir::ElementsAttr::Trait"]}, {"name": "Builtin_DenseStringElementsAttr", "cppName": "DenseElementsAttr", "numParameters": 2, "dialect": "builtin", "parameters": [{"name": "type", "cppType": "ShapedType"}, {"name": "value", "cppType": "ArrayRef<StringRef>"}], "hasVerifier": false, "traits": [], "interfaces": ["::mlir::ElementsAttr::Trait"]}, {"name": "Builtin_DictionaryAttr", "cppName": "::mlir::Attribute", "numParameters": 1, "dialect": "builtin", "parameters": [{"name": "value", "cppType": "::llvm::ArrayRef<NamedAttribute>"}], "hasVerifier": false, "traits": [], "interfaces": ["::mlir::SubElementAttrInterface::Trait"]}, {"name": "Builtin_FloatAttr", "cppName": "::mlir::Attribute", "numParameters": 2, "dialect": "builtin", "parameters": [{"name": "type", "cppType": "::mlir::Type"}, {"name": "value", "cppType": "::llvm::APFloat"}], "hasVerifier": true, "traits": [], "interfaces": []}, {"name": "Builtin_IntegerAttr", "cppName": "::mlir::Attribute", "numParameters": 2, "dialect": "builtin", "parameters": [{"name": "type", "cppType": "::mlir::Type"}, {"name": "value", "cppType": "APInt"}], "hasVerifier": true, "traits": [], "interfaces": []}, {"name": "Builtin_IntegerSetAttr", "cppName": "::mlir::Attribute", "numParameters": 1, "dialect": "builtin", "parameters": [{"name": "value", "cppType": "IntegerSet"}], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Builtin_OpaqueAttr", "cppName": "::mlir::Attribute", "numParameters": 3, "dialect": "builtin", "parameters": [{"name": "dialectNamespace", "cppType": "Identifier"}, {"name": "attrData", "cppType": "::llvm::StringRef"}, {"name": "type", "cppType": "::mlir::Type"}], "hasVerifier": true, "traits": [], "interfaces": []}, {"name": "Builtin_OpaqueElementsAttr", "cppName": "::mlir::Attribute", "numParameters": 3, "dialect": "builtin", "parameters": [{"name": "dialect", "cppType": "Identifier"}, {"name": "value", "cppType": "::llvm::StringRef"}, {"name": "type", "cppType": "ShapedType"}], "hasVerifier": true, "traits": [], "interfaces": ["::mlir::ElementsAttr::Trait"]}, {"name": "Builtin_SparseElementsAttr", "cppName": "::mlir::Attribute", "numParameters": 3, "dialect": "builtin", "parameters": [{"name": "type", "cppType": "ShapedType"}, {"name": "indices", "cppType": "DenseIntElementsAttr"}, {"name": "values", "cppType": "DenseElementsAttr"}], "hasVerifier": true, "traits": [], "interfaces": ["::mlir::ElementsAttr::Trait"]}, {"name": "Builtin_StringAttr", "cppName": "::mlir::Attribute", "numParameters": 2, "dialect": "builtin", "parameters": [{"name": "value", "cppType": "::llvm::StringRef"}, {"name": "type", "cppType": "::mlir::Type"}], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Builtin_SymbolRefAttr", "cppName": "::mlir::Attribute", "numParameters": 2, "dialect": "builtin", "parameters": [{"name": "rootReference", "cppType": "StringAttr"}, {"name": "nestedReferences", "cppType": "::llvm::ArrayRef<FlatSymbolRefAttr>"}], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Builtin_TypeAttr", "cppName": "::mlir::Attribute", "numParameters": 1, "dialect": "builtin", "parameters": [{"name": "value", "cppType": "Type"}], "hasVerifier": false, "traits": [], "interfaces": ["::mlir::SubElementAttrInterface::Trait"]}, {"name": "Builtin_UnitAttr", "cppName": "::mlir::Attribute", "numParameters": 0, "dialect": "builtin", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}]}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": [{"name": "SparseTensorEncodingAttr", "cppName": "::mlir::Attribute", "numParameters": 4, "dialect": "sparse_tensor", "parameters": [{"name": "dimLevelType", "cppType": "::llvm::ArrayRef<SparseTensorEncodingAttr::DimLevelType>"}, {"name": "dimOrdering", "cppType": "AffineMap"}, {"name": "pointerBitWidth", "cppType": "unsigned"}, {"name": "indexBitWidth", "cppType": "unsigned"}], "hasVerifier": true, "traits": [], "interfaces": ["::mlir::VerifiableTensorEncoding::Trait"]}]}, {"ops": [{"name": "sparse_tensor.convert", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "dest", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "sparse_tensor", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "source", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "sparse_tensor.new", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "sparse_tensor", "traits": [], "hasVerifier": true, "operands": [{"name": "source", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "sparse_tensor.release", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "sparse_tensor", "traits": [], "hasVerifier": true, "operands": [{"name": "tensor", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "sparse_tensor.indices", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(((($_self.isa<::mlir::MemRefType>())) && ((true))) && (( isStrided($_self.cast<::mlir::MemRefType>()) ))) && (((($_self.isa<::mlir::MemRefType>())) && ((true))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyStridedMemRefOfRank"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "sparse_tensor", "traits": [], "hasVerifier": true, "operands": [{"name": "tensor", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "dim", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "sparse_tensor.pointers", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(((($_self.isa<::mlir::MemRefType>())) && ((true))) && (( isStrided($_self.cast<::mlir::MemRefType>()) ))) && (((($_self.isa<::mlir::MemRefType>())) && ((true))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyStridedMemRefOfRank"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "sparse_tensor", "traits": [], "hasVerifier": true, "operands": [{"name": "tensor", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "dim", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "sparse_tensor.tensor", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "sparse_tensor", "traits": [], "hasVerifier": true, "operands": [{"name": "memrefs", "constraint": {"kind": "variadic", "baseType": {"predicate": "(((($_self.isa<::mlir::MemRefType>())) && ((true))) && (( isStrided($_self.cast<::mlir::MemRefType>()) ))) && (((($_self.isa<::mlir::MemRefType>())) && ((true))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyStridedMemRefOfRank"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "sparse_tensor.values", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(((($_self.isa<::mlir::MemRefType>())) && ((true))) && (( isStrided($_self.cast<::mlir::MemRefType>()) ))) && (((($_self.isa<::mlir::MemRefType>())) && ((true))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyStridedMemRefOfRank"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "sparse_tensor", "traits": [], "hasVerifier": true, "operands": [{"name": "tensor", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": [{"name": "SparseTensorEncodingAttr", "cppName": "::mlir::Attribute", "numParameters": 4, "dialect": "sparse_tensor", "parameters": [{"name": "dimLevelType", "cppType": "::llvm::ArrayRef<SparseTensorEncodingAttr::DimLevelType>"}, {"name": "dimOrdering", "cppType": "AffineMap"}, {"name": "pointerBitWidth", "cppType": "unsigned"}, {"name": "indexBitWidth", "cppType": "unsigned"}], "hasVerifier": true, "traits": [], "interfaces": ["::mlir::VerifiableTensorEncoding::Trait"]}]}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [{"name": "tosa.apply_scale", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"double_round": {"predicate": "($_self.isa<::mlir::BoolAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (($_self.isUnsignedInteger(8))) || ((($_self.isSignlessInteger(8))) || (($_self.isSignlessInteger(16))) || (($_self.isSignlessInteger(32))) || (($_self.isSignlessInteger(48))) || (($_self.isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "value", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (($_self.isUnsignedInteger(8))) || ((($_self.isSignlessInteger(8))) || (($_self.isSignlessInteger(16))) || (($_self.isSignlessInteger(32))) || (($_self.isSignlessInteger(48))) || (($_self.isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "multiplier", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (($_self.isUnsignedInteger(8))) || ((($_self.isSignlessInteger(8))) || (($_self.isSignlessInteger(16))) || (($_self.isSignlessInteger(32))) || (($_self.isSignlessInteger(48))) || (($_self.isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "shift", "constraint": {"predicate": "(($_self.isSignlessInteger(8))) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8)))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))))", "superclass": ["Constraint", "TypeConstraint", "Tosa_TypeLike"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.yield", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "inputs", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [{"name": "tosa.abs", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.add", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ResultsBroadcastableShape", "kind": "native"}, {"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input2", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.apply_scale", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"double_round": {"predicate": "($_self.isa<::mlir::BoolAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (($_self.isUnsignedInteger(8))) || ((($_self.isSignlessInteger(8))) || (($_self.isSignlessInteger(16))) || (($_self.isSignlessInteger(32))) || (($_self.isSignlessInteger(48))) || (($_self.isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "value", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (($_self.isUnsignedInteger(8))) || ((($_self.isSignlessInteger(8))) || (($_self.isSignlessInteger(16))) || (($_self.isSignlessInteger(32))) || (($_self.isSignlessInteger(48))) || (($_self.isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "multiplier", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (($_self.isUnsignedInteger(8))) || ((($_self.isSignlessInteger(8))) || (($_self.isSignlessInteger(16))) || (($_self.isSignlessInteger(32))) || (($_self.isSignlessInteger(48))) || (($_self.isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "shift", "constraint": {"predicate": "(($_self.isSignlessInteger(8))) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8)))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))))", "superclass": ["Constraint", "TypeConstraint", "Tosa_TypeLike"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.argmax", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"axis": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 0)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.arithmetic_right_shift", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"round": {"predicate": "($_self.isa<::mlir::BoolAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ResultsBroadcastableShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input2", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.avg_pool2d", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"kernel": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 2))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}, "quantization_info": {"predicate": "($_self.isa<mlir::tosa::UnaryOpQuantizationAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "pad": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 4))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}, "stride": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 2))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 4))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": true, "operands": [{"name": "input", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 4))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.bitwise_and", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ResultsBroadcastableShape", "kind": "native"}, {"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input2", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.bitwise_not", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ResultsBroadcastableShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.bitwise_or", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ResultsBroadcastableShape", "kind": "native"}, {"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input2", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.bitwise_xor", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ResultsBroadcastableShape", "kind": "native"}, {"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input2", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.cast", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferShapedTypeOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.ceil", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.clamp", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"max_int": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}, "min_fp": {"predicate": "(($_self.isa<::mlir::FloatAttr>())) && (($_self.cast<::mlir::FloatAttr>().getType().isF32()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "FloatAttrBase"], "kind": "predicate"}, "max_fp": {"predicate": "(($_self.isa<::mlir::FloatAttr>())) && (($_self.cast<::mlir::FloatAttr>().getType().isF32()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "FloatAttrBase"], "kind": "predicate"}, "min_int": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.clz", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.concat", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"axis": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "tosa.const", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"value": {"predicate": "($_self.isa<::mlir::ElementsAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "ElementsAttrBase"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ConstantLike", "kind": "native"}, {"name": "::mlir::OpTrait::FirstAttrDerivedResultType", "kind": "internal"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "tosa.conv2d", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"quantization_info": {"predicate": "($_self.isa<mlir::tosa::ConvOpQuantizationAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "dilation": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 2))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}, "pad": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 4))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}, "stride": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 2))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 4))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": true, "operands": [{"name": "input", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 4))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "weight", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 4))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "bias", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.conv3d", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"quantization_info": {"predicate": "($_self.isa<mlir::tosa::ConvOpQuantizationAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "dilation": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 3))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}, "pad": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 6))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}, "stride": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 3))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 5))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": true, "operands": [{"name": "input", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 5))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "weight", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 5))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "bias", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.custom", "numResults": 1, "interfaces": ["TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"identifier": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "outputs", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "inputs", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "tosa.depthwise_conv2d", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"quantization_info": {"predicate": "($_self.isa<mlir::tosa::ConvOpQuantizationAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "dilation": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 2))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}, "pad": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 4))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}, "stride": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 2))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 4))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": true, "operands": [{"name": "input", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 4))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "weight", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 4))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "bias", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.div", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ResultsBroadcastableShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input2", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.equal", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ResultsBroadcastableShape", "kind": "native"}, {"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input2", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.exp", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.floor", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.fully_connected", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"quantization_info": {"predicate": "($_self.isa<mlir::tosa::ConvOpQuantizationAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 2))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": true, "operands": [{"name": "input", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 2))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "weight", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 2))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "bias", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.gather", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 3))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "values", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 3))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"predicate": "((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32)))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)))", "superclass": ["Constraint", "TypeConstraint", "Type", "TensorRankOf", "2DTensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.greater_equal", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ResultsBroadcastableShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input2", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.greater", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ResultsBroadcastableShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input2", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.identity", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferShapedTypeOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.cond_if", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 2, "attributes": {}, "numOperands": 2, "results": [{"name": "output", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::SingleBlockImplicitTerminator<YieldOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::HasRecursiveSideEffects", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "cond", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "inputs", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "tosa.log", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.logical_and", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "z", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ResultsBroadcastableShape", "kind": "native"}, {"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input2", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.logical_left_shift", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ResultsBroadcastableShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input2", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.logical_not", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.logical_or", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "z", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ResultsBroadcastableShape", "kind": "native"}, {"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input2", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.logical_right_shift", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ResultsBroadcastableShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input2", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.logical_xor", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "z", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ResultsBroadcastableShape", "kind": "native"}, {"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input2", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.matmul", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"quantization_info": {"predicate": "($_self.isa<mlir::tosa::MatMulOpQuantizationAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "c", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 3))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 3))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 3))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.max_pool2d", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"kernel": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 2))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}, "pad": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 4))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}, "stride": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 2))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 4))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 4))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.maximum", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ResultsBroadcastableShape", "kind": "native"}, {"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input2", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.minimum", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ResultsBroadcastableShape", "kind": "native"}, {"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input2", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.mul", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"shift": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ResultsBroadcastableShape", "kind": "native"}, {"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input2", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.negate", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"quantization_info": {"predicate": "($_self.isa<mlir::tosa::UnaryOpQuantizationAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.pad", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"quantization_info": {"predicate": "($_self.isa<mlir::tosa::PadOpQuantizationAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().hasRank()))) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "RankedTensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().hasRank()))) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "RankedTensorOf"], "kind": "predicate"}}, {"name": "padding", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.pow", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "z", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ResultsBroadcastableShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input2", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.reciprocal", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.reduce_all", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"axis": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.reduce_any", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"axis": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.reduce_max", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"axis": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.reduce_min", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"axis": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.reduce_prod", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"axis": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.reduce_sum", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"axis": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.reluN", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"max_int": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}, "max_fp": {"predicate": "(($_self.isa<::mlir::FloatAttr>())) && (($_self.cast<::mlir::FloatAttr>().getType().isF32()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "FloatAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.rescale", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferShapedTypeOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"double_round": {"predicate": "($_self.isa<::mlir::BoolAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "multiplier": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "input_zp": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}, "output_zp": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}, "scale32": {"predicate": "($_self.isa<::mlir::BoolAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "shift": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "per_channel": {"predicate": "($_self.isa<::mlir::BoolAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.reshape", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"new_shape": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().hasRank()))) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "RankedTensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.resize", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"stride_fp": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::FloatAttr>())) && ((attr.cast<::mlir::FloatAttr>().getType().isF32())); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 2))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}, "mode": {"predicate": "($_self.cast<StringAttr>().getValue() == \"BILINEAR\"  || $_self.cast<StringAttr>().getValue() == \"NEAREST_NEIGHBOR\")", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}, "offset": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 2))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}, "output_size": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 2))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}, "stride": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 2))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}, "offset_fp": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::FloatAttr>())) && ((attr.cast<::mlir::FloatAttr>().getType().isF32())); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 2))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}, "shift": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 4))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 4))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.reverse", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"axis": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.rsqrt", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.scatter", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "values_out", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 3))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "values_in", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 3))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"predicate": "((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32)))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)))", "superclass": ["Constraint", "TypeConstraint", "Type", "TensorRankOf", "2DTensorOf"], "kind": "predicate"}}, {"name": "input", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 3))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.select", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input2", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input3", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.sigmoid", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.slice", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"size": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "start": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 5)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 6)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 5)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 6)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.sub", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::ResultsBroadcastableShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "input2", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.table", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "table", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.tanh", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.tile", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"multiples": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.transpose_conv2d", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"quantization_info": {"predicate": "($_self.isa<mlir::tosa::ConvOpQuantizationAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "dilation": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 2))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}, "out_shape": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() <= 4))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}, "stride": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 2))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}, "out_pad": {"predicate": "((($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && (($_self.cast<::mlir::ArrayAttr>().size() == 2))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 4))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 4))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "filter", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 4))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "bias", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.transpose", "numResults": 1, "interfaces": ["::mlir::InferShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 5)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 6)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tosa", "traits": [], "hasVerifier": false, "operands": [{"name": "input1", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedTensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) || (((($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && ((($_self.cast<::mlir::ShapedType>().getRank()                          == 1)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 3)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 4)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 5)) || (($_self.cast<::mlir::ShapedType>().getRank()                          == 6)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "perms", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tosa.while_loop", "numResults": 1, "interfaces": ["::mlir::LoopLikeOpInterface::Trait", "::mlir::InferShapedTypeOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 2, "attributes": {}, "numOperands": 1, "results": [{"name": "output", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::SingleBlockImplicitTerminator<YieldOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::HasRecursiveSideEffects", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "inputs", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "tosa.yield", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "TosaOp::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "tosa", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "inputs", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || (((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [{"name": "scf.condition", "numResults": 0, "interfaces": ["::mlir::RegionBranchTerminatorOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "scf", "traits": [{"name": "::mlir::OpTrait::HasParent<WhileOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "condition", "constraint": {"kind": "integer", "bitwidth": 1}}, {"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "scf.execute_region", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {}, "numOperands": 0, "results": [{"name": "", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "scf", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "scf.for", "numResults": 1, "interfaces": ["::mlir::LoopLikeOpInterface::Trait", "::mlir::RegionBranchOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {}, "numOperands": 4, "results": [{"name": "results", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "scf", "traits": [{"name": "::mlir::OpTrait::SingleBlockImplicitTerminator<scf::YieldOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::HasRecursiveSideEffects", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "lowerBound", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "upperBound", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "step", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "initArgs", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "scf.if", "numResults": 1, "interfaces": ["::mlir::RegionBranchOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 2, "attributes": {}, "numOperands": 1, "results": [{"name": "results", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "scf", "traits": [{"name": "::mlir::OpTrait::SingleBlockImplicitTerminator<scf::YieldOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::HasRecursiveSideEffects", "kind": "native"}, {"name": "::mlir::OpTrait::NoRegionArguments", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "condition", "constraint": {"kind": "integer", "bitwidth": 1}}], "numSuccessors": 0}, {"name": "scf.parallel", "numResults": 1, "interfaces": ["::mlir::LoopLikeOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {}, "numOperands": 4, "results": [{"name": "results", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 4, "dialect": "scf", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}, {"name": "::mlir::OpTrait::HasRecursiveSideEffects", "kind": "native"}, {"name": "::mlir::OpTrait::SingleBlockImplicitTerminator<scf::YieldOp>::Impl", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "lowerBound", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "upperBound", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "step", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "initVals", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "scf.reduce", "numResults": 0, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "scf", "traits": [{"name": "::mlir::OpTrait::HasParent<ParallelOp>::Impl", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "scf.reduce.return", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "scf", "traits": [{"name": "::mlir::OpTrait::HasParent<ReduceOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "scf.while", "numResults": 1, "interfaces": ["::mlir::RegionBranchOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 2, "attributes": {}, "numOperands": 1, "results": [{"name": "results", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "scf", "traits": [{"name": "::mlir::OpTrait::HasRecursiveSideEffects", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "inits", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "scf.yield", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "scf", "traits": [{"name": "::mlir::OpTrait::ReturnLike", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}, {"name": "::mlir::OpTrait::HasParent<ExecuteRegionOp, ForOp, IfOp, ParallelOp, WhileOp>::Impl", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "results", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [{"name": "quant.const_fake_quant", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"num_bits": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}, "min": {"predicate": "(($_self.isa<::mlir::FloatAttr>())) && (($_self.cast<::mlir::FloatAttr>().getType().isF32()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "FloatAttrBase"], "kind": "predicate"}, "narrow_range": {"predicate": "($_self.isa<::mlir::BoolAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "DefaultValuedAttr"], "kind": "predicate"}, "max": {"predicate": "(($_self.isa<::mlir::FloatAttr>())) && (($_self.cast<::mlir::FloatAttr>().getType().isF32()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "FloatAttrBase"], "kind": "predicate"}, "is_signed": {"predicate": "($_self.isa<::mlir::BoolAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "DefaultValuedAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "outputs", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF32()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "quant", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "inputs", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF32()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "quant.const_fake_quant_per_axis", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"num_bits": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}, "min": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::FloatAttr>())) && ((attr.cast<::mlir::FloatAttr>().getType().isF32())); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "axis": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}, "max": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::FloatAttr>())) && ((attr.cast<::mlir::FloatAttr>().getType().isF32())); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "narrow_range": {"predicate": "($_self.isa<::mlir::BoolAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "DefaultValuedAttr"], "kind": "predicate"}, "is_signed": {"predicate": "($_self.isa<::mlir::BoolAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "DefaultValuedAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "outputs", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF32()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "quant", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "inputs", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF32()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "quant.coupled_ref", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"coupledKey": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "((($_self.isa<::mlir::FloatType>())) || (($_self.isa<mlir::quant::QuantizedType>()))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())))) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "quant_TypedPrimitiveOrContainer"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "quant", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"predicate": "((($_self.isa<::mlir::FloatType>())) || (($_self.isa<mlir::quant::QuantizedType>()))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())))) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "quant_TypedPrimitiveOrContainer"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "quant.dcast", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "((($_self.isa<::mlir::FloatType>())) || (($_self.isa<mlir::quant::QuantizedType>()))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())))) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "quant_TypedPrimitiveOrContainer"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "quant", "traits": [], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"predicate": "((($_self.isa<::mlir::FloatType>())) || (($_self.isa<mlir::quant::QuantizedType>()))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())))) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "quant_TypedPrimitiveOrContainer"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "quant.qcast", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "((($_self.isa<::mlir::FloatType>())) || (($_self.isa<mlir::quant::QuantizedType>()))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())))) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "quant_TypedPrimitiveOrContainer"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "quant", "traits": [], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"predicate": "((($_self.isa<::mlir::FloatType>())) || (($_self.isa<mlir::quant::QuantizedType>()))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())))) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "quant_TypedPrimitiveOrContainer"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "quant.region", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {"logical_kernel": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}, "input_specs": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "output_specs": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "outputs", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "quant", "traits": [{"name": "::mlir::OpTrait::IsIsolatedFromAbove", "kind": "native"}, {"name": "::mlir::OpTrait::SingleBlockImplicitTerminator<ReturnOp>::Impl", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "inputs", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "quant.return", "numResults": 0, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "quant", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "results", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "quant.stats", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"axisStats": {"predicate": "($_self.isa<::mlir::ElementsAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "axis": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "layerStats": {"predicate": "($_self.isa<::mlir::ElementsAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "ElementsAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "((($_self.isa<::mlir::FloatType>())) || (($_self.isa<mlir::quant::QuantizedType>()))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())))) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "quant_TypedPrimitiveOrContainer"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "quant", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "arg", "constraint": {"predicate": "((($_self.isa<::mlir::FloatType>())) || (($_self.isa<mlir::quant::QuantizedType>()))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())))) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "quant_TypedPrimitiveOrContainer"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "quant.stats_ref", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"statsKey": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "((($_self.isa<::mlir::FloatType>())) || (($_self.isa<mlir::quant::QuantizedType>()))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())))) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "quant_TypedPrimitiveOrContainer"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "quant", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"predicate": "((($_self.isa<::mlir::FloatType>())) || (($_self.isa<mlir::quant::QuantizedType>()))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())))) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "quant_TypedPrimitiveOrContainer"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "quant.scast", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "(((($_self.isa<::mlir::FloatType>())) || (($_self.isa<mlir::quant::QuantizedType>()))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())))) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>()))))) || (((($_self.isSignlessInteger())) || (($_self.isa<mlir::quant::QuantizedType>()))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())))) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())))))", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "quant", "traits": [], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"predicate": "(((($_self.isa<::mlir::FloatType>())) || (($_self.isa<mlir::quant::QuantizedType>()))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())))) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>()))))) || (((($_self.isSignlessInteger())) || (($_self.isa<mlir::quant::QuantizedType>()))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())))) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())))))", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [{"name": "spv.Undef", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [{"name": "spv.AccessChain", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "component_ptr", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "base_ptr", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "spv.mlir.addressof", "numResults": 1, "interfaces": ["::mlir::OpAsmOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"variable": {"predicate": "($_self.isa<::mlir::FlatSymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "pointer", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isNestedInFunctionLikeOp($_op.getParentOp()))"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.AtomicAnd", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"memory_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "semantics": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "pointer", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "value", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.AtomicCompareExchangeWeak", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"unequal_semantics": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}, "memory_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "equal_semantics": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "pointer", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "value", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}, {"name": "comparator", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.AtomicIAdd", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"memory_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "semantics": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "pointer", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "value", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.AtomicIDecrement", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"memory_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "semantics": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "pointer", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.AtomicIIncrement", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"memory_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "semantics": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "pointer", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.AtomicISub", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"memory_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "semantics": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "pointer", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "value", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.AtomicOr", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"memory_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "semantics": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "pointer", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "value", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.AtomicSMax", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"memory_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "semantics": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "pointer", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "value", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.AtomicSMin", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"memory_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "semantics": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "pointer", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "value", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.AtomicUMax", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"memory_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "semantics": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "pointer", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "value", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.AtomicUMin", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"memory_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "semantics": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "pointer", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "value", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.AtomicXor", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"memory_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "semantics": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "pointer", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "value", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.BitCount", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.BitFieldInsert", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 4, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$base.getType(), $insert.getType(), $result.getType()})))"}], "hasVerifier": false, "operands": [{"name": "base", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "insert", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "offset", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}, {"name": "count", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.BitFieldSExtract", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::SignedOp", "kind": "native"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$base.getType(), $result.getType()})))"}], "hasVerifier": false, "operands": [{"name": "base", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "offset", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}, {"name": "count", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.BitFieldUExtract", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$base.getType(), $result.getType()})))"}], "hasVerifier": false, "operands": [{"name": "base", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "offset", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}, {"name": "count", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.BitReverse", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.Bitcast", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(((((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64())))) || (($_self.isSignlessInteger(1)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))) || (($_self.isa<::mlir::spirv::PointerType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "(((((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64())))) || (($_self.isSignlessInteger(1)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))) || (($_self.isa<::mlir::spirv::PointerType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.BitwiseAnd", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.BitwiseOr", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.BitwiseXor", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.BranchConditional", "numResults": 0, "interfaces": ["::mlir::BranchOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"branch_weights": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 3, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 2, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}, {"kind": "pred", "pred": "(isNestedInFunctionLikeOp($_op.getParentOp()))"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "condition", "constraint": {"predicate": "($_self.isSignlessInteger(1))", "superclass": ["Constraint", "TypeConstraint", "Type", "TypeAlias"], "kind": "predicate"}}, {"name": "trueTargetOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}, {"name": "falseTargetOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}], "numSuccessors": 2}, {"name": "spv.Branch", "numResults": 0, "interfaces": ["::mlir::BranchOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isNestedInFunctionLikeOp($_op.getParentOp()))"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "targetOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}], "numSuccessors": 1}, {"name": "spv.CompositeConstruct", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "constituents", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "spv.CompositeExtract", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"indices": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "component", "constraint": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "composite", "constraint": {"predicate": "(((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.CompositeInsert", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"indices": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "object", "constraint": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "composite", "constraint": {"predicate": "(((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.Constant", "numResults": 1, "interfaces": ["::mlir::OpAsmOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"value": {"predicate": "(true)", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "constant", "constraint": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::ConstantLike", "kind": "native"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.ControlBarrier", "numResults": 0, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"memory_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "execution_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "memory_semantics": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.ConvertFToS", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ConvertFToU", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ConvertSToF", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::SignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ConvertUToF", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.CooperativeMatrixLengthNV", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"type": {"predicate": "(($_self.isa<::mlir::TypeAttr>())) && (($_self.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypeAttrBase"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "result", "constraint": {"predicate": "($_self.isSignlessInteger(32))", "superclass": ["Constraint", "TypeConstraint", "Type", "TypeAlias"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "spv.CooperativeMatrixLoadNV", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"memory_access": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemoryAccess($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "pointer", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "stride", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}, {"name": "columnmajor", "constraint": {"predicate": "($_self.isSignlessInteger(1))", "superclass": ["Constraint", "TypeConstraint", "Type", "TypeAlias"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.CooperativeMatrixMulAddNV", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$c.getType(), $result.getType()})))"}], "hasVerifier": true, "operands": [{"name": "a", "constraint": {"predicate": "($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "c", "constraint": {"predicate": "($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.CooperativeMatrixStoreNV", "numResults": 0, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"memory_access": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemoryAccess($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 4, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "pointer", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "object", "constraint": {"predicate": "($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "stride", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}, {"name": "columnmajor", "constraint": {"predicate": "($_self.isSignlessInteger(1))", "superclass": ["Constraint", "TypeConstraint", "Type", "TypeAlias"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.CopyMemory", "numResults": 0, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"source_alignment": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "memory_access": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemoryAccess($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "source_memory_access": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemoryAccess($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "alignment": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "target", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "source", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.EntryPoint", "numResults": 0, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"interface": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::SymbolRefAttr>()); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "execution_model": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeExecutionModel($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "fn": {"predicate": "($_self.isa<::mlir::FlatSymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isDirectInModuleLikeOp($_op.getParentOp()))"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.ExecutionMode", "numResults": 0, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"values": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "fn": {"predicate": "($_self.isa<::mlir::FlatSymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "execution_mode": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeExecutionMode($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isDirectInModuleLikeOp($_op.getParentOp()))"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "spv.FAdd", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FConvert", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FDiv", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FMod", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FMul", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FNegate", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FOrdEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FOrdGreaterThanEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FOrdGreaterThan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FOrdLessThanEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FOrdLessThan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FOrdNotEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FRem", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FSub", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FUnordEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FUnordGreaterThanEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FUnordGreaterThan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FUnordLessThanEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FUnordLessThan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FUnordNotEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.func", "numResults": 0, "interfaces": ["::mlir::CallableOpInterface::Trait", "::mlir::SymbolOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {"type": {"predicate": "(($_self.isa<::mlir::TypeAttr>())) && (($_self.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypeAttrBase"], "kind": "predicate"}, "function_control": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeFunctionControl($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}, "sym_name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::AutomaticAllocationScope", "kind": "native"}, {"name": "::mlir::OpTrait::FunctionLike", "kind": "native"}, {"kind": "pred", "pred": "(isDirectInModuleLikeOp($_op.getParentOp()))"}, {"name": "::mlir::OpTrait::IsIsolatedFromAbove", "kind": "native"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "spv.FunctionCall", "numResults": 1, "interfaces": ["::mlir::CallOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"callee": {"predicate": "($_self.isa<::mlir::FlatSymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "result", "constraint": {"kind": "optional", "baseType": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isNestedInFunctionLikeOp($_op.getParentOp()))"}], "hasVerifier": true, "operands": [{"name": "arguments", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "spv.GLSL.Acos", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Asin", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Atan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Ceil", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Cos", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Cosh", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Exp", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.FAbs", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.FClamp", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "x", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "y", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "z", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.FMax", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.FMin", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.FMix", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$x.getType(), $y.getType(), $a.getType(), $result.getType()})))"}], "hasVerifier": false, "operands": [{"name": "x", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "y", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "a", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.FSign", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Floor", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Fma", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "x", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "y", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "z", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.FrexpStruct", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::spirv::StructType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.InverseSqrt", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Ldexp", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "y", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$x.getType(), $y.getType()})))"}], "hasVerifier": true, "operands": [{"name": "x", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "exp", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Log", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Pow", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Round", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.SAbs", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.SClamp", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isSignedInteger(8))) || (($_self.isSignedInteger(16))) || (($_self.isSignedInteger(32))) || (($_self.isSignedInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "x", "constraint": {"predicate": "((($_self.isSignedInteger(8))) || (($_self.isSignedInteger(16))) || (($_self.isSignedInteger(32))) || (($_self.isSignedInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "y", "constraint": {"predicate": "((($_self.isSignedInteger(8))) || (($_self.isSignedInteger(16))) || (($_self.isSignedInteger(32))) || (($_self.isSignedInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "z", "constraint": {"predicate": "((($_self.isSignedInteger(8))) || (($_self.isSignedInteger(16))) || (($_self.isSignedInteger(32))) || (($_self.isSignedInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.SMax", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.SMin", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.SSign", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Sin", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Sinh", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Sqrt", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Tan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Tanh", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.UClamp", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "(((($_self.isSignlessInteger(8))) || (($_self.isUnsignedInteger(8)))) || ((($_self.isSignlessInteger(16))) || (($_self.isUnsignedInteger(16)))) || ((($_self.isSignlessInteger(32))) || (($_self.isUnsignedInteger(32)))) || ((($_self.isSignlessInteger(64))) || (($_self.isUnsignedInteger(64))))) || (((($_self.isa<::mlir::VectorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64)))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "x", "constraint": {"predicate": "(((($_self.isSignlessInteger(8))) || (($_self.isUnsignedInteger(8)))) || ((($_self.isSignlessInteger(16))) || (($_self.isUnsignedInteger(16)))) || ((($_self.isSignlessInteger(32))) || (($_self.isUnsignedInteger(32)))) || ((($_self.isSignlessInteger(64))) || (($_self.isUnsignedInteger(64))))) || (((($_self.isa<::mlir::VectorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64)))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "y", "constraint": {"predicate": "(((($_self.isSignlessInteger(8))) || (($_self.isUnsignedInteger(8)))) || ((($_self.isSignlessInteger(16))) || (($_self.isUnsignedInteger(16)))) || ((($_self.isSignlessInteger(32))) || (($_self.isUnsignedInteger(32)))) || ((($_self.isSignlessInteger(64))) || (($_self.isUnsignedInteger(64))))) || (((($_self.isa<::mlir::VectorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64)))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "z", "constraint": {"predicate": "(((($_self.isSignlessInteger(8))) || (($_self.isUnsignedInteger(8)))) || ((($_self.isSignlessInteger(16))) || (($_self.isUnsignedInteger(16)))) || ((($_self.isSignlessInteger(32))) || (($_self.isUnsignedInteger(32)))) || ((($_self.isSignlessInteger(64))) || (($_self.isUnsignedInteger(64))))) || (((($_self.isa<::mlir::VectorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64)))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.UMax", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.UMin", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GlobalVariable", "numResults": 0, "interfaces": ["::mlir::SymbolOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"type": {"predicate": "(($_self.isa<::mlir::TypeAttr>())) && (($_self.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypeAttrBase"], "kind": "predicate"}, "initializer": {"predicate": "($_self.isa<::mlir::FlatSymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "builtin": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "sym_name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}, "location": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "binding": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "descriptorSet": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isDirectInModuleLikeOp($_op.getParentOp()))"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.GroupBroadcast", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"execution_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$value.getType(), $result.getType()})))"}], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "localid", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GroupNonUniformBallot", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"execution_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64)))))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType", "SPV_Vec4"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "predicate", "constraint": {"predicate": "($_self.isSignlessInteger(1))", "superclass": ["Constraint", "TypeConstraint", "Type", "TypeAlias"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GroupNonUniformBroadcast", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"execution_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$value.getType(), $result.getType()})))"}], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "id", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GroupNonUniformElect", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"execution_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "result", "constraint": {"predicate": "($_self.isSignlessInteger(1))", "superclass": ["Constraint", "TypeConstraint", "Type", "TypeAlias"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.GroupNonUniformFAdd", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"execution_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "group_operation": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "cluster_size", "constraint": {"kind": "optional", "baseType": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "spv.GroupNonUniformFMax", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"execution_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "group_operation": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "cluster_size", "constraint": {"kind": "optional", "baseType": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "spv.GroupNonUniformFMin", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"execution_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "group_operation": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "cluster_size", "constraint": {"kind": "optional", "baseType": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "spv.GroupNonUniformFMul", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"execution_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "group_operation": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "cluster_size", "constraint": {"kind": "optional", "baseType": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "spv.GroupNonUniformIAdd", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"execution_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "group_operation": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "cluster_size", "constraint": {"kind": "optional", "baseType": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "spv.GroupNonUniformIMul", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"execution_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "group_operation": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "cluster_size", "constraint": {"kind": "optional", "baseType": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "spv.GroupNonUniformSMax", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"execution_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "group_operation": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::SignedOp", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "cluster_size", "constraint": {"kind": "optional", "baseType": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "spv.GroupNonUniformSMin", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"execution_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "group_operation": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::SignedOp", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "cluster_size", "constraint": {"kind": "optional", "baseType": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "spv.GroupNonUniformUMax", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"execution_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "group_operation": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "cluster_size", "constraint": {"kind": "optional", "baseType": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "spv.GroupNonUniformUMin", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"execution_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "group_operation": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "cluster_size", "constraint": {"kind": "optional", "baseType": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "spv.IAdd", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.IEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.IMul", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.INotEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ISub", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ImageDrefGather", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"imageoperands": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeImageOperands($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 4, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "sampledimage", "constraint": {"predicate": "($_self.isa<::mlir::spirv::SampledImageType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "coordinate", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "dref", "constraint": {"predicate": "(($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "FloatOfWidths"], "kind": "predicate"}}, {"name": "operand_arguments", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "spv.Image", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::spirv::ImageType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()($sampledimage.getType().cast<spirv::SampledImageType>().getImageType(), $result.getType()))"}], "hasVerifier": false, "operands": [{"name": "sampledimage", "constraint": {"predicate": "($_self.isa<::mlir::spirv::SampledImageType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ImageQuerySize", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "image", "constraint": {"predicate": "($_self.isa<::mlir::spirv::ImageType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.InBoundsPtrAccessChain", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "base_ptr", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "element", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "spv.IsInf", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.IsNan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.Load", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"memory_access": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemoryAccess($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "alignment": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "value", "constraint": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "ptr", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.LogicalAnd", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.LogicalEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.LogicalNotEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.LogicalNot", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.LogicalOr", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.mlir.loop", "numResults": 0, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {"loop_control": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeLoopControl($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isNestedInFunctionLikeOp($_op.getParentOp()))"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.MatrixTimesMatrix", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::spirv::MatrixType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "leftmatrix", "constraint": {"predicate": "($_self.isa<::mlir::spirv::MatrixType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "rightmatrix", "constraint": {"predicate": "($_self.isa<::mlir::spirv::MatrixType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.MatrixTimesScalar", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::spirv::MatrixType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "matrix", "constraint": {"predicate": "($_self.isa<::mlir::spirv::MatrixType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "scalar", "constraint": {"predicate": "(($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "FloatOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.MemoryBarrier", "numResults": 0, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"memory_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "memory_semantics": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.mlir.merge", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.module", "numResults": 0, "interfaces": ["::mlir::SymbolOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {"addressing_model": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeAddressingModel($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "memory_model": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemoryModel($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "sym_name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "vce_triple": {"predicate": "($_self.isa<::mlir::spirv::VerCapExtAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsIsolatedFromAbove", "kind": "native"}, {"name": "::mlir::OpTrait::NoRegionArguments", "kind": "native"}, {"name": "::mlir::OpTrait::NoTerminator", "kind": "native"}, {"name": "::mlir::OpTrait::SingleBlock", "kind": "native"}, {"name": "::mlir::OpTrait::SymbolTable", "kind": "native"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.Not", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.OCL.exp", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.OCL.fabs", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.OCL.s_abs", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.Ordered", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.PtrAccessChain", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "base_ptr", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "element", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "spv.mlir.referenceof", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"spec_const": {"predicate": "($_self.isa<::mlir::FlatSymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "reference", "constraint": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.Return", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isNestedInFunctionLikeOp($_op.getParentOp()))"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.ReturnValue", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isNestedInFunctionLikeOp($_op.getParentOp()))"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SConvert", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::SignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SDiv", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SGreaterThanEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::SignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SGreaterThan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::SignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SLessThanEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::SignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SLessThan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::SignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SMod", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SNegate", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SRem", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.Select", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "((((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64())))) || (($_self.isSignlessInteger(1)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$true_value.getType(), $false_value.getType(), $result.getType()})))"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "condition", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "true_value", "constraint": {"predicate": "((((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64())))) || (($_self.isSignlessInteger(1)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "false_value", "constraint": {"predicate": "((((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64())))) || (($_self.isSignlessInteger(1)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.mlir.selection", "numResults": 0, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {"selection_control": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeSelectionControl($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isNestedInFunctionLikeOp($_op.getParentOp()))"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.ShiftLeftLogical", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ShiftRightArithmetic", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ShiftRightLogical", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SpecConstantComposite", "numResults": 0, "interfaces": ["::mlir::SymbolOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"type": {"predicate": "(($_self.isa<::mlir::TypeAttr>())) && (($_self.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypeAttrBase"], "kind": "predicate"}, "constituents": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::SymbolRefAttr>()); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "sym_name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isDirectInModuleLikeOp($_op.getParentOp()))"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.SpecConstant", "numResults": 0, "interfaces": ["::mlir::SymbolOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"default_value": {"predicate": "(true)", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "sym_name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isDirectInModuleLikeOp($_op.getParentOp()))"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.SpecConstantOperation", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {}, "numOperands": 0, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isNestedInFunctionLikeOp($_op.getParentOp()))"}, {"name": "::mlir::OpTrait::SingleBlockImplicitTerminator<YieldOp>::Impl", "kind": "native"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.Store", "numResults": 0, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"memory_access": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemoryAccess($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "alignment": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "ptr", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "value", "constraint": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SubgroupBallotKHR", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32)))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType", "SPV_Vec4"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "predicate", "constraint": {"predicate": "($_self.isSignlessInteger(1))", "superclass": ["Constraint", "TypeConstraint", "Type", "TypeAlias"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SubgroupBlockReadINTEL", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "value", "constraint": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "ptr", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SubgroupBlockWriteINTEL", "numResults": 0, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "ptr", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "value", "constraint": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.Transpose", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::spirv::MatrixType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "matrix", "constraint": {"predicate": "($_self.isa<::mlir::spirv::MatrixType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.UConvert", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.UDiv", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.UGreaterThanEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.UGreaterThan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ULessThanEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ULessThan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.UMod", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.Undef", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "spv.Unordered", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.Unreachable", "numResults": 0, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isNestedInFunctionLikeOp($_op.getParentOp()))"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.Variable", "numResults": 1, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"storage_class": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeStorageClass($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "pointer", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "initializer", "constraint": {"kind": "optional", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "spv.VectorExtractDynamic", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64())))) || (($_self.isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()($vector.getType().cast<mlir::VectorType>().getElementType(), $result.getType()))"}], "hasVerifier": false, "operands": [{"name": "vector", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "index", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.VectorInsertDynamic", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()($vector.getType().cast<mlir::VectorType>().getElementType(), $component.getType()))"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$vector.getType(), $result.getType()})))"}], "hasVerifier": false, "operands": [{"name": "vector", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "component", "constraint": {"predicate": "(((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64())))) || (($_self.isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "index", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.VectorShuffle", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"components": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({getElementTypeOrSelf($vector1), getElementTypeOrSelf($vector2), getElementTypeOrSelf($result)})))"}], "hasVerifier": true, "operands": [{"name": "vector1", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "vector2", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.mlir.yield", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::HasParent<SpecConstantOperationOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [{"name": "spv.BitCount", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.BitFieldInsert", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 4, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$base.getType(), $insert.getType(), $result.getType()})))"}], "hasVerifier": false, "operands": [{"name": "base", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "insert", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "offset", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}, {"name": "count", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.BitFieldSExtract", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::SignedOp", "kind": "native"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$base.getType(), $result.getType()})))"}], "hasVerifier": false, "operands": [{"name": "base", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "offset", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}, {"name": "count", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.BitFieldUExtract", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$base.getType(), $result.getType()})))"}], "hasVerifier": false, "operands": [{"name": "base", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "offset", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}, {"name": "count", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.BitReverse", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.BitwiseAnd", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.BitwiseOr", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.BitwiseXor", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.Not", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ShiftLeftLogical", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ShiftRightArithmetic", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ShiftRightLogical", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [{"name": "spv.Bitcast", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(((((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64())))) || (($_self.isSignlessInteger(1)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))) || (($_self.isa<::mlir::spirv::PointerType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "(((((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64())))) || (($_self.isSignlessInteger(1)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))) || (($_self.isa<::mlir::spirv::PointerType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ConvertFToS", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ConvertFToU", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ConvertSToF", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::SignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ConvertUToF", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FConvert", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SConvert", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::SignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.UConvert", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [{"name": "spv.GLSL.Acos", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Asin", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Atan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Ceil", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Cos", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Cosh", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Exp", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.FAbs", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.FClamp", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "x", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "y", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "z", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.FMax", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.FMin", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.FMix", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$x.getType(), $y.getType(), $a.getType(), $result.getType()})))"}], "hasVerifier": false, "operands": [{"name": "x", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "y", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "a", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.FSign", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Floor", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Fma", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "x", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "y", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "z", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.FrexpStruct", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::spirv::StructType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.InverseSqrt", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Ldexp", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "y", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$x.getType(), $y.getType()})))"}], "hasVerifier": true, "operands": [{"name": "x", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "exp", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Log", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Pow", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Round", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.SAbs", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.SClamp", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isSignedInteger(8))) || (($_self.isSignedInteger(16))) || (($_self.isSignedInteger(32))) || (($_self.isSignedInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "x", "constraint": {"predicate": "((($_self.isSignedInteger(8))) || (($_self.isSignedInteger(16))) || (($_self.isSignedInteger(32))) || (($_self.isSignedInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "y", "constraint": {"predicate": "((($_self.isSignedInteger(8))) || (($_self.isSignedInteger(16))) || (($_self.isSignedInteger(32))) || (($_self.isSignedInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "z", "constraint": {"predicate": "((($_self.isSignedInteger(8))) || (($_self.isSignedInteger(16))) || (($_self.isSignedInteger(32))) || (($_self.isSignedInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.SMax", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.SMin", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.SSign", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Sin", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Sinh", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Sqrt", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Tan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.Tanh", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.UClamp", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "(((($_self.isSignlessInteger(8))) || (($_self.isUnsignedInteger(8)))) || ((($_self.isSignlessInteger(16))) || (($_self.isUnsignedInteger(16)))) || ((($_self.isSignlessInteger(32))) || (($_self.isUnsignedInteger(32)))) || ((($_self.isSignlessInteger(64))) || (($_self.isUnsignedInteger(64))))) || (((($_self.isa<::mlir::VectorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64)))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "x", "constraint": {"predicate": "(((($_self.isSignlessInteger(8))) || (($_self.isUnsignedInteger(8)))) || ((($_self.isSignlessInteger(16))) || (($_self.isUnsignedInteger(16)))) || ((($_self.isSignlessInteger(32))) || (($_self.isUnsignedInteger(32)))) || ((($_self.isSignlessInteger(64))) || (($_self.isUnsignedInteger(64))))) || (((($_self.isa<::mlir::VectorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64)))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "y", "constraint": {"predicate": "(((($_self.isSignlessInteger(8))) || (($_self.isUnsignedInteger(8)))) || ((($_self.isSignlessInteger(16))) || (($_self.isUnsignedInteger(16)))) || ((($_self.isSignlessInteger(32))) || (($_self.isUnsignedInteger(32)))) || ((($_self.isSignlessInteger(64))) || (($_self.isUnsignedInteger(64))))) || (((($_self.isa<::mlir::VectorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64)))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "z", "constraint": {"predicate": "(((($_self.isSignlessInteger(8))) || (($_self.isUnsignedInteger(8)))) || ((($_self.isSignlessInteger(16))) || (($_self.isUnsignedInteger(16)))) || ((($_self.isSignlessInteger(32))) || (($_self.isUnsignedInteger(32)))) || ((($_self.isSignlessInteger(64))) || (($_self.isUnsignedInteger(64))))) || (((($_self.isa<::mlir::VectorType>())) && (((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(8)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(16)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(32)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))) || (($_self.cast<::mlir::ShapedType>().getElementType().isUnsignedInteger(64)))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.UMax", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.GLSL.UMin", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [{"name": "spv.ControlBarrier", "numResults": 0, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"memory_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "execution_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "memory_semantics": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.MemoryBarrier", "numResults": 0, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"memory_scope": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "memory_semantics": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [{"name": "spv.FAdd", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FDiv", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FMod", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FMul", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FNegate", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FRem", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FSub", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.IAdd", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.IMul", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ISub", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SDiv", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SMod", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SNegate", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SRem", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.UDiv", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.UMod", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || ((($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) && ((($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOrCoopMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [{"name": "spv.FOrdEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FOrdGreaterThanEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FOrdGreaterThan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FOrdLessThanEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FOrdLessThan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FOrdNotEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FUnordEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FUnordGreaterThanEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FUnordGreaterThan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FUnordLessThanEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FUnordLessThan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.FUnordNotEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.IEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.INotEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.IsInf", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.IsNan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.LogicalAnd", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.LogicalEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.LogicalNotEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.LogicalNot", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.LogicalOr", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.Ordered", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SGreaterThanEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::SignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SGreaterThan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::SignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SLessThanEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::SignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.SLessThan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::SignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.Select", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "((((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64())))) || (($_self.isSignlessInteger(1)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$true_value.getType(), $false_value.getType(), $result.getType()})))"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "condition", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "true_value", "constraint": {"predicate": "((((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64())))) || (($_self.isSignlessInteger(1)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "false_value", "constraint": {"predicate": "((((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64())))) || (($_self.isSignlessInteger(1)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.UGreaterThanEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.UGreaterThan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ULessThanEqual", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ULessThan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UnsignedOp", "kind": "native"}, {"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.Unordered", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand1", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "operand2", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [{"name": "spv.mlir.addressof", "numResults": 1, "interfaces": ["::mlir::OpAsmOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"variable": {"predicate": "($_self.isa<::mlir::FlatSymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "pointer", "constraint": {"predicate": "($_self.isa<::mlir::spirv::PointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isNestedInFunctionLikeOp($_op.getParentOp()))"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.Constant", "numResults": 1, "interfaces": ["::mlir::OpAsmOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"value": {"predicate": "(true)", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "constant", "constraint": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::ConstantLike", "kind": "native"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.EntryPoint", "numResults": 0, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"interface": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::SymbolRefAttr>()); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "execution_model": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeExecutionModel($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "fn": {"predicate": "($_self.isa<::mlir::FlatSymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isDirectInModuleLikeOp($_op.getParentOp()))"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.ExecutionMode", "numResults": 0, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"values": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "fn": {"predicate": "($_self.isa<::mlir::FlatSymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "execution_mode": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeExecutionMode($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isDirectInModuleLikeOp($_op.getParentOp()))"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "spv.func", "numResults": 0, "interfaces": ["::mlir::CallableOpInterface::Trait", "::mlir::SymbolOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {"type": {"predicate": "(($_self.isa<::mlir::TypeAttr>())) && (($_self.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypeAttrBase"], "kind": "predicate"}, "function_control": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeFunctionControl($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}, "sym_name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::AutomaticAllocationScope", "kind": "native"}, {"name": "::mlir::OpTrait::FunctionLike", "kind": "native"}, {"kind": "pred", "pred": "(isDirectInModuleLikeOp($_op.getParentOp()))"}, {"name": "::mlir::OpTrait::IsIsolatedFromAbove", "kind": "native"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "spv.GlobalVariable", "numResults": 0, "interfaces": ["::mlir::SymbolOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"type": {"predicate": "(($_self.isa<::mlir::TypeAttr>())) && (($_self.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypeAttrBase"], "kind": "predicate"}, "initializer": {"predicate": "($_self.isa<::mlir::FlatSymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "builtin": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "sym_name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}, "location": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "binding": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "descriptorSet": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isDirectInModuleLikeOp($_op.getParentOp()))"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.module", "numResults": 0, "interfaces": ["::mlir::SymbolOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {"addressing_model": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeAddressingModel($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "memory_model": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemoryModel($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I32EnumAttr", "SPV_I32EnumAttr"], "kind": "predicate"}, "sym_name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "vce_triple": {"predicate": "($_self.isa<::mlir::spirv::VerCapExtAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsIsolatedFromAbove", "kind": "native"}, {"name": "::mlir::OpTrait::NoRegionArguments", "kind": "native"}, {"name": "::mlir::OpTrait::NoTerminator", "kind": "native"}, {"name": "::mlir::OpTrait::SingleBlock", "kind": "native"}, {"name": "::mlir::OpTrait::SymbolTable", "kind": "native"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.mlir.referenceof", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"spec_const": {"predicate": "($_self.isa<::mlir::FlatSymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "reference", "constraint": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.SpecConstantComposite", "numResults": 0, "interfaces": ["::mlir::SymbolOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"type": {"predicate": "(($_self.isa<::mlir::TypeAttr>())) && (($_self.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypeAttrBase"], "kind": "predicate"}, "constituents": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::SymbolRefAttr>()); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "sym_name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isDirectInModuleLikeOp($_op.getParentOp()))"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.SpecConstant", "numResults": 0, "interfaces": ["::mlir::SymbolOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"default_value": {"predicate": "(true)", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "sym_name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isDirectInModuleLikeOp($_op.getParentOp()))"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.SpecConstantOperation", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {}, "numOperands": 0, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isNestedInFunctionLikeOp($_op.getParentOp()))"}, {"name": "::mlir::OpTrait::SingleBlockImplicitTerminator<YieldOp>::Impl", "kind": "native"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.mlir.yield", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::HasParent<SpecConstantOperationOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [{"name": "spv.CompositeConstruct", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "constituents", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "spv.CompositeExtract", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"indices": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "component", "constraint": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "composite", "constraint": {"predicate": "(((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.CompositeInsert", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"indices": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::spirv::UsableInSpecConstantOp", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "object", "constraint": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "composite", "constraint": {"predicate": "(((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.VectorExtractDynamic", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64())))) || (($_self.isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()($vector.getType().cast<mlir::VectorType>().getElementType(), $result.getType()))"}], "hasVerifier": false, "operands": [{"name": "vector", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "index", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.VectorInsertDynamic", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()($vector.getType().cast<mlir::VectorType>().getElementType(), $component.getType()))"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$vector.getType(), $result.getType()})))"}], "hasVerifier": false, "operands": [{"name": "vector", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "component", "constraint": {"predicate": "(((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64())))) || (($_self.isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "index", "constraint": {"predicate": "(($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "AnyIntOfWidths"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.VectorShuffle", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"components": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({getElementTypeOrSelf($vector1), getElementTypeOrSelf($vector2), getElementTypeOrSelf($result)})))"}], "hasVerifier": true, "operands": [{"name": "vector1", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "vector2", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [{"name": "spv.ImageDrefGather", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"imageoperands": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeImageOperands($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 4, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "sampledimage", "constraint": {"predicate": "($_self.isa<::mlir::spirv::SampledImageType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "coordinate", "constraint": {"predicate": "((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "dref", "constraint": {"predicate": "(($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "FloatOfWidths"], "kind": "predicate"}}, {"name": "operand_arguments", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "spv.Image", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::spirv::ImageType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()($sampledimage.getType().cast<spirv::SampledImageType>().getImageType(), $result.getType()))"}], "hasVerifier": false, "operands": [{"name": "sampledimage", "constraint": {"predicate": "($_self.isa<::mlir::spirv::SampledImageType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.ImageQuerySize", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "SPV_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [], "hasVerifier": true, "operands": [{"name": "image", "constraint": {"predicate": "($_self.isa<::mlir::spirv::ImageType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [{"name": "spv.BranchConditional", "numResults": 0, "interfaces": ["::mlir::BranchOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"branch_weights": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 3, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 2, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}, {"kind": "pred", "pred": "(isNestedInFunctionLikeOp($_op.getParentOp()))"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "condition", "constraint": {"predicate": "($_self.isSignlessInteger(1))", "superclass": ["Constraint", "TypeConstraint", "Type", "TypeAlias"], "kind": "predicate"}}, {"name": "trueTargetOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}, {"name": "falseTargetOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}], "numSuccessors": 2}, {"name": "spv.Branch", "numResults": 0, "interfaces": ["::mlir::BranchOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isNestedInFunctionLikeOp($_op.getParentOp()))"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "targetOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}], "numSuccessors": 1}, {"name": "spv.FunctionCall", "numResults": 1, "interfaces": ["::mlir::CallOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"callee": {"predicate": "($_self.isa<::mlir::FlatSymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "result", "constraint": {"kind": "optional", "baseType": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isNestedInFunctionLikeOp($_op.getParentOp()))"}], "hasVerifier": true, "operands": [{"name": "arguments", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "spv.mlir.loop", "numResults": 0, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {"loop_control": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeLoopControl($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isNestedInFunctionLikeOp($_op.getParentOp()))"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.mlir.merge", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.Return", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isNestedInFunctionLikeOp($_op.getParentOp()))"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.ReturnValue", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isNestedInFunctionLikeOp($_op.getParentOp()))"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "(($_self.isa<::mlir::NoneType>())) || (($_self.isSignlessInteger(1))) || ((($_self.isInteger(8))) || (($_self.isInteger(16))) || (($_self.isInteger(32))) || (($_self.isInteger(64)))) || ((($_self.isF16())) || (($_self.isF32())) || (($_self.isF64()))) || (((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isInteger(64)))) || ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 2)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 3)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16))))) || (($_self.isa<::mlir::spirv::PointerType>())) || (($_self.isa<::mlir::spirv::ArrayType>())) || (($_self.isa<::mlir::spirv::RuntimeArrayType>())) || (($_self.isa<::mlir::spirv::StructType>())) || (($_self.isa<::mlir::spirv::CooperativeMatrixNVType>())) || (($_self.isa<::mlir::spirv::MatrixType>())) || (($_self.isa<::mlir::spirv::SampledImageType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "spv.mlir.selection", "numResults": 0, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {"selection_control": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeSelectionControl($_self.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "BitEnumAttr", "SPV_BitEnumAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isNestedInFunctionLikeOp($_op.getParentOp()))"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "spv.Unreachable", "numResults": 0, "interfaces": ["::mlir::spirv::QueryMinVersionInterface::Trait", "::mlir::spirv::QueryMaxVersionInterface::Trait", "::mlir::spirv::QueryExtensionInterface::Trait", "::mlir::spirv::QueryCapabilityInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "spv", "traits": [{"kind": "pred", "pred": "(isNestedInFunctionLikeOp($_op.getParentOp()))"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [{"name": "vector.bitcast", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "vector", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$source.getType().cast<::mlir::ShapedType>().getRank(), $result.getType().cast<::mlir::ShapedType>().getRank()})))"}], "hasVerifier": true, "operands": [{"name": "source", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.broadcast", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "vector", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "vector", "traits": [{"kind": "pred", "pred": "(getElementTypeOrSelf($_op.getResult(0)) == getElementTypeOrSelf($_op.getOperand(0)))"}], "hasVerifier": true, "operands": [{"name": "source", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.compressstore", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 4, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "vector", "traits": [], "hasVerifier": true, "operands": [{"name": "base", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "mask", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}, {"name": "valueToStore", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRank"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.constant_mask", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"mask_dim_sizes": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "vector", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "vector.contract", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"indexing_maps": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::AffineMapAttr>()); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "kind": {"predicate": "($_self.isa<::mlir::vector::CombiningKindAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "DefaultValuedAttr"], "kind": "predicate"}, "iterator_types": {"predicate": "($_self.isa<::mlir::ArrayAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase"], "kind": "predicate"}}, "numOperands": 4, "results": [{"name": "", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "vector", "traits": [{"kind": "pred", "pred": "(($_op.getNumOperands() > 1)) && (($_op.getOperand(0).getType().isa<::mlir::ShapedType>())) && (($_op.getOperand(1).getType().isa<::mlir::ShapedType>())) && ((::mlir::getElementTypeOrSelf($_op.getOperand(0)) == ::mlir::getElementTypeOrSelf($_op.getOperand(1))))"}, {"kind": "pred", "pred": "(getElementTypeOrSelf($_op.getResult(0)) == getElementTypeOrSelf($_op.getOperand(2)))"}], "hasVerifier": true, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}, {"name": "acc", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "masks", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "vector.create_mask", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "vector", "traits": [], "hasVerifier": true, "operands": [{"name": "operands", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "vector.expandload", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 4, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRank"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "vector", "traits": [], "hasVerifier": true, "operands": [{"name": "base", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "mask", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}, {"name": "pass_thru", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRank"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.extractelement", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "vector", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()($vector.getType().cast<ShapedType>().getElementType(), $result.getType()))"}], "hasVerifier": true, "operands": [{"name": "vector", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}, {"name": "position", "constraint": {"predicate": "($_self.isSignlessInteger())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.extract_map", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "vector", "traits": [], "hasVerifier": true, "operands": [{"name": "vector", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}, {"name": "ids", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "vector.extract", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"position": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "vector", "traits": [{"kind": "pred", "pred": "(getElementTypeOrSelf($_op.getResult(0)) == getElementTypeOrSelf($_op.getOperand(0)))"}], "hasVerifier": true, "operands": [{"name": "vector", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.extract_strided_slice", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"offsets": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "sizes": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "strides": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "vector", "traits": [{"kind": "pred", "pred": "(getElementTypeOrSelf($_op.getResult(0)) == getElementTypeOrSelf($_op.getOperand(0)))"}], "hasVerifier": true, "operands": [{"name": "vector", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.fma", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "vector", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$lhs.getType(), $rhs.getType(), $acc.getType(), $result.getType()})))"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}, {"name": "acc", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.flat_transpose", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"columns": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}, "rows": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "vector", "traits": [{"kind": "pred", "pred": "(getElementTypeOrSelf($_op.getResult(0)) == getElementTypeOrSelf($_op.getOperand(0)))"}], "hasVerifier": false, "operands": [{"name": "matrix", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.gather", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 5, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRank"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "vector", "traits": [], "hasVerifier": true, "operands": [{"name": "base", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "index_vec", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IntegerType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}, {"name": "mask", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}, {"name": "pass_thru", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRank"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.insertelement", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "vector", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()($result.getType().cast<ShapedType>().getElementType(), $source.getType()))"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$dest.getType(), $result.getType()})))"}], "hasVerifier": true, "operands": [{"name": "source", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "dest", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}, {"name": "position", "constraint": {"predicate": "($_self.isSignlessInteger())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.insert_map", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "vector", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$dest.getType(), $result.getType()})))"}], "hasVerifier": true, "operands": [{"name": "vector", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}, {"name": "dest", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}, {"name": "ids", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "vector.insert", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"position": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "vector", "traits": [{"kind": "pred", "pred": "(getElementTypeOrSelf($_op.getResult(0)) == getElementTypeOrSelf($_op.getOperand(0)))"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$dest.getType(), $res.getType()})))"}], "hasVerifier": true, "operands": [{"name": "source", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "dest", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.insert_strided_slice", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"offsets": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "strides": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "vector", "traits": [{"kind": "pred", "pred": "(getElementTypeOrSelf($_op.getResult(0)) == getElementTypeOrSelf($_op.getOperand(0)))"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$dest.getType(), $res.getType()})))"}], "hasVerifier": true, "operands": [{"name": "source", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}, {"name": "dest", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.load", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "vector", "traits": [], "hasVerifier": true, "operands": [{"name": "base", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "vector.maskedload", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 4, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRank"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "vector", "traits": [], "hasVerifier": true, "operands": [{"name": "base", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "mask", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}, {"name": "pass_thru", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRank"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.maskedstore", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 4, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "vector", "traits": [], "hasVerifier": true, "operands": [{"name": "base", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "mask", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}, {"name": "valueToStore", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRank"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.matrix_multiply", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"lhs_rows": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}, "lhs_columns": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}, "rhs_columns": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "vector", "traits": [{"kind": "pred", "pred": "(getElementTypeOrSelf($_op.getResult(0)) == getElementTypeOrSelf($_op.getOperand(0)))"}, {"kind": "pred", "pred": "(getElementTypeOrSelf($_op.getResult(0)) == getElementTypeOrSelf($_op.getOperand(1)))"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignedInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.multi_reduction", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"kind": {"predicate": "($_self.isa<::mlir::vector::CombiningKindAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "DialectAttr"], "kind": "predicate"}, "reduction_dims": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "dest", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "vector", "traits": [{"kind": "pred", "pred": "(getElementTypeOrSelf($_op.getResult(0)) == getElementTypeOrSelf($_op.getOperand(0)))"}], "hasVerifier": true, "operands": [{"name": "source", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.outerproduct", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"kind": {"predicate": "($_self.isa<::mlir::vector::CombiningKindAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "DefaultValuedAttr"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "vector", "traits": [{"kind": "pred", "pred": "(getElementTypeOrSelf($_op.getResult(0)) == getElementTypeOrSelf($_op.getOperand(0)))"}, {"kind": "pred", "pred": "(getElementTypeOrSelf($_op.getResult(0)) == getElementTypeOrSelf($_op.getOperand(1)))"}], "hasVerifier": true, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "acc", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "vector.print", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "vector", "traits": [], "hasVerifier": false, "operands": [{"name": "source", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.reduction", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"kind": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "dest", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "vector", "traits": [{"kind": "pred", "pred": "(getElementTypeOrSelf($_op.getResult(0)) == getElementTypeOrSelf($_op.getOperand(0)))"}], "hasVerifier": true, "operands": [{"name": "vector", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}, {"name": "acc", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "vector.reshape", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"fixed_vector_sizes": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 2, "dialect": "vector", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "vector", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}, {"name": "input_shape", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "output_shape", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "vector.scatter", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 5, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "vector", "traits": [], "hasVerifier": true, "operands": [{"name": "base", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "index_vec", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IntegerType>())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}, {"name": "mask", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}, {"name": "valueToStore", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 1))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRank"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.shape_cast", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "vector", "traits": [], "hasVerifier": true, "operands": [{"name": "source", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.shuffle", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"mask": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "vector", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "vector", "traits": [{"kind": "pred", "pred": "(getElementTypeOrSelf($_op.getResult(0)) == getElementTypeOrSelf($_op.getOperand(0)))"}, {"kind": "pred", "pred": "(getElementTypeOrSelf($_op.getResult(0)) == getElementTypeOrSelf($_op.getOperand(1)))"}], "hasVerifier": true, "operands": [{"name": "v1", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}, {"name": "v2", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.store", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "vector", "traits": [], "hasVerifier": true, "operands": [{"name": "valueToStore", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}, {"name": "base", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "vector.transfer_read", "numResults": 1, "interfaces": ["::mlir::VectorTransferOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"in_bounds": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::BoolAttr>()); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "permutation_map": {"predicate": "($_self.isa<::mlir::AffineMapAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 4, "results": [{"name": "vector", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 2, "dialect": "vector", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "source", "constraint": {"predicate": "(($_self.isa<::mlir::ShapedType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "padding", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "mask", "constraint": {"kind": "optional", "baseType": {"predicate": "(($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "vector.transfer_write", "numResults": 1, "interfaces": ["::mlir::VectorTransferOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"in_bounds": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::BoolAttr>()); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "permutation_map": {"predicate": "($_self.isa<::mlir::AffineMapAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 4, "results": [{"name": "result", "constraint": {"kind": "optional", "baseType": {"predicate": "((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().hasRank()))) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "RankedTensorOf"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 2, "dialect": "vector", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "vector", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}, {"name": "source", "constraint": {"predicate": "(($_self.isa<::mlir::ShapedType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "mask", "constraint": {"kind": "optional", "baseType": {"predicate": "(($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "vector.transpose", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"transp": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "vector", "traits": [{"kind": "pred", "pred": "(getElementTypeOrSelf($_op.getResult(0)) == getElementTypeOrSelf($_op.getOperand(0)))"}], "hasVerifier": true, "operands": [{"name": "vector", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "vector.type_cast", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::ViewLikeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "vector", "traits": [], "hasVerifier": true, "operands": [{"name": "memref", "constraint": {"predicate": "((($_self.isa<::mlir::MemRefType>())) && ((true))) && (($_self.cast<::mlir::ShapedType>().hasStaticShape()))", "superclass": ["Constraint", "TypeConstraint", "Type", "StaticShapeMemRefOf"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [{"name": "x86vector.avx.intr.dp.ps.256", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF32()))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "x86vector", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$a.getType(), $b.getType(), $res.getType()})))"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF32()))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF32()))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "c", "constraint": {"kind": "integer", "bitwidth": 8}}], "numSuccessors": 0}, {"name": "x86vector.avx.intr.dot", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF32()))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "x86vector", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF32()))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF32()))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "x86vector.avx512.intr.mask.compress", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "x86vector", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$a.getType(), $src.getType(), $res.getType()})))"}, {"kind": "pred", "pred": "(std::equal_to<>()(VectorType::get({$res.getType().cast<VectorType>().getShape()[0]}, IntegerType::get($res.getType().getContext(), 1)), $k.getType()))"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "src", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "k", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "x86vector.avx512.mask.compress", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"constant_src": {"predicate": "($_self.isa<::mlir::ElementsAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "dst", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "x86vector", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$a.getType(), $dst.getType()})))"}, {"kind": "pred", "pred": "(std::equal_to<>()(VectorType::get({$dst.getType().cast<VectorType>().getShape()[0]}, IntegerType::get($dst.getType().getContext(), 1)), $k.getType()))"}], "hasVerifier": true, "operands": [{"name": "k", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "a", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "src", "constraint": {"kind": "optional", "baseType": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "x86vector.avx512.mask.rndscale", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 5, "results": [{"name": "dst", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "x86vector", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src.getType(), $a.getType(), $dst.getType()})))"}, {"kind": "pred", "pred": "(std::equal_to<>()(IntegerType::get($dst.getType().getContext(), ($dst.getType().cast<VectorType>().getShape()[0])), $imm.getType()))"}], "hasVerifier": false, "operands": [{"name": "src", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "k", "constraint": {"kind": "integer", "bitwidth": 32}}, {"name": "a", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "imm", "constraint": {"predicate": "(($_self.isSignlessInteger(16))) || (($_self.isSignlessInteger(8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "rounding", "constraint": {"kind": "integer", "bitwidth": 32}}], "numSuccessors": 0}, {"name": "x86vector.avx512.intr.mask.rndscale.pd.512", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 5, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "x86vector", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src.getType(), $a.getType(), $res.getType()})))"}], "hasVerifier": false, "operands": [{"name": "src", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "k", "constraint": {"kind": "integer", "bitwidth": 32}}, {"name": "a", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "imm", "constraint": {"kind": "integer", "bitwidth": 8}}, {"name": "rounding", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "x86vector.avx512.intr.mask.rndscale.ps.512", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 5, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "x86vector", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src.getType(), $a.getType(), $res.getType()})))"}], "hasVerifier": false, "operands": [{"name": "src", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF32()))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "k", "constraint": {"kind": "integer", "bitwidth": 32}}, {"name": "a", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF32()))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "imm", "constraint": {"kind": "integer", "bitwidth": 16}}, {"name": "rounding", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "x86vector.avx512.mask.scalef", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 5, "results": [{"name": "dst", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "x86vector", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src.getType(), $a.getType(), $b.getType(), $dst.getType()})))"}, {"kind": "pred", "pred": "(std::equal_to<>()(IntegerType::get($dst.getType().getContext(), ($dst.getType().cast<VectorType>().getShape()[0])), $k.getType()))"}], "hasVerifier": false, "operands": [{"name": "src", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "a", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF64())))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "k", "constraint": {"predicate": "(($_self.isSignlessInteger(16))) || (($_self.isSignlessInteger(8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "rounding", "constraint": {"kind": "integer", "bitwidth": 32}}], "numSuccessors": 0}, {"name": "x86vector.avx512.intr.mask.scalef.pd.512", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 5, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "x86vector", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src.getType(), $a.getType(), $b.getType(), $res.getType()})))"}], "hasVerifier": false, "operands": [{"name": "src", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "a", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF64()))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "k", "constraint": {"kind": "integer", "bitwidth": 8}}, {"name": "rounding", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "x86vector.avx512.intr.mask.scalef.ps.512", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 5, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "x86vector", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src.getType(), $a.getType(), $b.getType(), $res.getType()})))"}], "hasVerifier": false, "operands": [{"name": "src", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF32()))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "a", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF32()))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF32()))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "k", "constraint": {"kind": "integer", "bitwidth": 16}}, {"name": "rounding", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "x86vector.avx.intr.rsqrt.ps.256", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "x86vector", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF32()))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "x86vector.avx.rsqrt", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "b", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF32()))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "x86vector", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isF32()))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "x86vector.avx512.intr.vp2intersect.d.512", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "x86vector", "traits": [], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32)))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32)))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "x86vector.avx512.vp2intersect", "numResults": 2, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "k1", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "k2", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "x86vector", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$a.getType(), $b.getType()})))"}, {"kind": "pred", "pred": "(std::equal_to<>()(VectorType::get({$a.getType().cast<VectorType>().getShape()[0]}, IntegerType::get($a.getType().getContext(), 1)), $k1.getType()))"}, {"kind": "pred", "pred": "(std::equal_to<>()(VectorType::get({$a.getType().cast<VectorType>().getShape()[0]}, IntegerType::get($a.getType().getContext(), 1)), $k2.getType()))"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "x86vector.avx512.intr.vp2intersect.q.512", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "x86vector", "traits": [], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64)))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64)))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [{"name": "memref.assume_alignment", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"alignment": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && (($_self.cast<IntegerAttr>().getValue().isStrictlyPositive()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "memref", "traits": [], "hasVerifier": true, "operands": [{"name": "memref", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "memref.clone", "numResults": 1, "interfaces": ["::mlir::CopyOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::AllocationOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedMemRefType>())) && ((true))) || ((($_self.isa<::mlir::MemRefType>())) && ((true)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "memref", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedMemRefType>())) && ((true))) || ((($_self.isa<::mlir::MemRefType>())) && ((true)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "memref.copy", "numResults": 0, "interfaces": ["::mlir::CopyOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "memref", "traits": [{"name": "::mlir::OpTrait::SameOperandsElementType", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "source", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedMemRefType>())) && ((true))) || ((($_self.isa<::mlir::MemRefType>())) && ((true)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "target", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedMemRefType>())) && ((true))) || ((($_self.isa<::mlir::MemRefType>())) && ((true)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "memref.load", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "memref", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()($memref.getType().cast<MemRefType>().getElementType(), $result.getType()))"}, {"name": "::mlir::OpTrait::MemRefsNormalizable", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "memref", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "memref.alloc", "numResults": 1, "interfaces": ["::mlir::AllocationOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"alignment": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))) && (($_self.cast<::mlir::IntegerAttr>().getInt() >= 0))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "memref", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 2, "dialect": "memref", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "dynamicSizes", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "symbolOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "memref.alloca", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"alignment": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))) && (($_self.cast<::mlir::IntegerAttr>().getInt() >= 0))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "memref", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 2, "dialect": "memref", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "dynamicSizes", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "symbolOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "memref.alloca_scope", "numResults": 1, "interfaces": ["::mlir::RegionBranchOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {}, "numOperands": 0, "results": [{"name": "results", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "memref", "traits": [{"name": "::mlir::OpTrait::AutomaticAllocationScope", "kind": "native"}, {"name": "::mlir::OpTrait::SingleBlockImplicitTerminator<AllocaScopeReturnOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::HasRecursiveSideEffects", "kind": "native"}, {"name": "::mlir::OpTrait::NoRegionArguments", "kind": "native"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "memref.alloca_scope.return", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "memref", "traits": [{"name": "::mlir::OpTrait::HasParent<AllocaScopeOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::ReturnLike", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "results", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "memref.buffer_cast", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "memref", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedMemRefType>())) && ((true))) || ((($_self.isa<::mlir::MemRefType>())) && ((true)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "memref", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultElementType", "kind": "native"}, {"kind": "pred", "pred": "(std::equal_to<>()(getTensorTypeFromMemRefType($memref.getType()), $tensor.getType()))"}], "hasVerifier": false, "operands": [{"name": "tensor", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "memref.cast", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::CastOpInterface::Trait", "::mlir::ViewLikeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "dest", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedMemRefType>())) && ((true))) || ((($_self.isa<::mlir::MemRefType>())) && ((true)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "memref", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}, {"name": "::mlir::OpTrait::MemRefsNormalizable", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "source", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedMemRefType>())) && ((true))) || ((($_self.isa<::mlir::MemRefType>())) && ((true)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "memref.collapse_shape", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::ViewLikeOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"reassociation": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(attr.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isa<::mlir::MemRefType>())) && ((true))) && (( isStrided($_self.cast<::mlir::MemRefType>()) ))", "superclass": ["Constraint", "TypeConstraint", "Type", "StridedMemRefOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "memref", "traits": [], "hasVerifier": true, "operands": [{"name": "src", "constraint": {"predicate": "((($_self.isa<::mlir::MemRefType>())) && ((true))) && (( isStrided($_self.cast<::mlir::MemRefType>()) ))", "superclass": ["Constraint", "TypeConstraint", "Type", "StridedMemRefOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "memref.dealloc", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "memref", "traits": [{"name": "::mlir::OpTrait::MemRefsNormalizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "memref", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedMemRefType>())) && ((true))) || ((($_self.isa<::mlir::MemRefType>())) && ((true)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "memref.dim", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "memref", "traits": [{"name": "::mlir::OpTrait::MemRefsNormalizable", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "source", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedMemRefType>())) && ((true))) || ((($_self.isa<::mlir::MemRefType>())) && ((true)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "index", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "memref.dma_start", "numResults": 0, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "memref", "traits": [], "hasVerifier": true, "operands": [{"name": "operands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "memref.dma_wait", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "memref", "traits": [], "hasVerifier": true, "operands": [{"name": "tagMemRef", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "tagIndices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "numElements", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "memref.expand_shape", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::ViewLikeOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"reassociation": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(attr.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isa<::mlir::MemRefType>())) && ((true))) && (( isStrided($_self.cast<::mlir::MemRefType>()) ))", "superclass": ["Constraint", "TypeConstraint", "Type", "StridedMemRefOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "memref", "traits": [], "hasVerifier": true, "operands": [{"name": "src", "constraint": {"predicate": "((($_self.isa<::mlir::MemRefType>())) && ((true))) && (( isStrided($_self.cast<::mlir::MemRefType>()) ))", "superclass": ["Constraint", "TypeConstraint", "Type", "StridedMemRefOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "memref.get_global", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::SymbolUserOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"name": {"predicate": "($_self.isa<::mlir::FlatSymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isa<::mlir::MemRefType>())) && ((true))) && (($_self.cast<::mlir::ShapedType>().hasStaticShape()))", "superclass": ["Constraint", "TypeConstraint", "Type", "StaticShapeMemRefOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "memref", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "memref.global", "numResults": 0, "interfaces": ["::mlir::SymbolOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"sym_visibility": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "type": {"predicate": "(($_self.isa<::mlir::TypeAttr>())) && (($_self.cast<::mlir::TypeAttr>().getValue().isa<::mlir::MemRefType>()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypeAttrBase"], "kind": "predicate"}, "initial_value": {"predicate": "(true)", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "sym_name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}, "constant": {"predicate": "($_self.isa<::mlir::UnitAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "alignment": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "memref", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "memref.prefetch", "numResults": 0, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"localityHint": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && (($_self.cast<::mlir::IntegerAttr>().getInt() >= 0)) && (($_self.cast<::mlir::IntegerAttr>().getInt() <= 3))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}, "isWrite": {"predicate": "($_self.isa<::mlir::BoolAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "isDataCache": {"predicate": "($_self.isa<::mlir::BoolAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 2, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "memref", "traits": [], "hasVerifier": true, "operands": [{"name": "memref", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "memref.reinterpret_cast", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::ViewLikeOpInterface::Trait", "::mlir::OffsetSizeAndStrideOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"static_offsets": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "static_sizes": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "static_strides": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 4, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 3, "dialect": "memref", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}, {"name": "::mlir::OpTrait::MemRefsNormalizable", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "source", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedMemRefType>())) && ((true))) || ((($_self.isa<::mlir::MemRefType>())) && ((true)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "offsets", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "sizes", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "strides", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "memref.reshape", "numResults": 1, "interfaces": ["::mlir::ViewLikeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedMemRefType>())) && ((true))) || ((($_self.isa<::mlir::MemRefType>())) && ((true)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "memref", "traits": [], "hasVerifier": true, "operands": [{"name": "source", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedMemRefType>())) && ((true))) || ((($_self.isa<::mlir::MemRefType>())) && ((true)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "shape", "constraint": {"predicate": "((($_self.isa<::mlir::MemRefType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "MemRefRankOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "memref.store", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "memref", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()($memref.getType().cast<MemRefType>().getElementType(), $value.getType()))"}, {"name": "::mlir::OpTrait::MemRefsNormalizable", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "memref", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "memref.transpose", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"permutation": {"predicate": "($_self.isa<::mlir::AffineMapAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "((($_self.isa<::mlir::MemRefType>())) && ((true))) && (( isStrided($_self.cast<::mlir::MemRefType>()) ))", "superclass": ["Constraint", "TypeConstraint", "Type", "StridedMemRefOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "memref", "traits": [], "hasVerifier": true, "operands": [{"name": "in", "constraint": {"predicate": "((($_self.isa<::mlir::MemRefType>())) && ((true))) && (( isStrided($_self.cast<::mlir::MemRefType>()) ))", "superclass": ["Constraint", "TypeConstraint", "Type", "StridedMemRefOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "memref.view", "numResults": 1, "interfaces": ["::mlir::ViewLikeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "memref", "traits": [], "hasVerifier": true, "operands": [{"name": "source", "constraint": {"predicate": "((($_self.isa<::mlir::MemRefType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8)))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "MemRefRankOf"], "kind": "predicate"}}, {"name": "byte_shift", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "sizes", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "memref.subview", "numResults": 1, "interfaces": ["::mlir::ViewLikeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::OffsetSizeAndStrideOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"static_offsets": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "static_sizes": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "static_strides": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 4, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 3, "dialect": "memref", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "source", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "offsets", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "sizes", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "strides", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "memref.tensor_load", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "memref", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultElementType", "kind": "native"}, {"kind": "pred", "pred": "(std::equal_to<>()(getTensorTypeFromMemRefType($memref.getType()), $result.getType()))"}], "hasVerifier": false, "operands": [{"name": "memref", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedMemRefType>())) && ((true))) || ((($_self.isa<::mlir::MemRefType>())) && ((true)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "memref.tensor_store", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "memref", "traits": [{"name": "::mlir::OpTrait::SameOperandsShape", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsElementType", "kind": "native"}, {"kind": "pred", "pred": "(std::equal_to<>()(getTensorTypeFromMemRefType($memref.getType()), $tensor.getType()))"}], "hasVerifier": false, "operands": [{"name": "tensor", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "memref", "constraint": {"predicate": "((($_self.isa<::mlir::UnrankedMemRefType>())) && ((true))) || ((($_self.isa<::mlir::MemRefType>())) && ((true)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [{"name": "arm_neon.intr.smull", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 2))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_neon", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$a.getType(), $b.getType()})))"}, {"kind": "pred", "pred": "(std::equal_to<>()($a.getType().cast<VectorType>().scaleElementBitwidth(2), $res.getType()))"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 2))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 8)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 2))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_neon.2d.sdot", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 2))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_neon", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$b.getType(), $c.getType()})))"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$a.getType(), $res.getType()})))"}, {"kind": "pred", "pred": "(a().getType().cast<VectorType>().getShape().size() == 1)"}, {"kind": "pred", "pred": "(b().getType().cast<VectorType>().getShape().size() == 2)"}, {"kind": "pred", "pred": "(b().getType().cast<VectorType>().getShape()[1] == 4)"}, {"kind": "pred", "pred": "(b().getType().cast<VectorType>().getShape()[0] == a().getType().cast<VectorType>().getShape()[0])"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 2))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "c", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_neon.intr.sdot", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 2))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_neon", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$b.getType(), $c.getType()})))"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$a.getType(), $res.getType()})))"}, {"kind": "pred", "pred": "(std::equal_to<>()(VectorType::get({$b.getType().cast<VectorType>().getShape()[0] / 4},IntegerType::get($b.getType().getContext(), 32)), $res.getType()))"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 4)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 2))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}, {"name": "c", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8)))) && ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::VectorType>().getNumElements()                            == 16)) || (($_self.cast<::mlir::VectorType>().getNumElements()                            == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfLengthAndType"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [{"name": "math.abs", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "math", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "math.atan2", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "math", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "math.atan", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "math", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "math.ceil", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "math", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "math.copysign", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "math", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "math.cos", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "math", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "math.exp2", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "math", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "math.expm1", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "math", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "math.exp", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "math", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "math.floor", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "math", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "math.fma", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "math", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "c", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "math.log10", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "math", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "math.log1p", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "math", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "math.log2", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "math", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "math.log", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "math", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "math.powf", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "math", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "math.rsqrt", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "math", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "math.sin", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "math", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "math.sqrt", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "math", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "math.tanh", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "math", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [{"name": "affine.apply", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"map": {"predicate": "($_self.isa<::mlir::AffineMapAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "affine", "traits": [], "hasVerifier": true, "operands": [{"name": "mapOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "affine.for", "numResults": 1, "interfaces": ["::mlir::LoopLikeOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {}, "numOperands": 1, "results": [{"name": "results", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "affine", "traits": [{"name": "::mlir::OpTrait::SingleBlockImplicitTerminator<AffineYieldOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::HasRecursiveSideEffects", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "affine.if", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 2, "attributes": {}, "numOperands": 1, "results": [{"name": "results", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "affine", "traits": [{"name": "::mlir::OpTrait::SingleBlockImplicitTerminator<AffineYieldOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::HasRecursiveSideEffects", "kind": "native"}, {"name": "::mlir::OpTrait::NoRegionArguments", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "affine.load", "numResults": 1, "interfaces": ["AffineReadOpInterface::Trait", "AffineMapAccessInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "affine", "traits": [{"name": "::mlir::OpTrait::MemRefsNormalizable", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "memref", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "affine.max", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"map": {"predicate": "($_self.isa<::mlir::AffineMapAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "affine", "traits": [], "hasVerifier": true, "operands": [{"name": "operands", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "affine.min", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"map": {"predicate": "($_self.isa<::mlir::AffineMapAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "affine", "traits": [], "hasVerifier": true, "operands": [{"name": "operands", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "affine.parallel", "numResults": 1, "interfaces": ["::mlir::LoopLikeOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {"reductions": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::AtomicRMWKindAttr>()); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "lowerBoundsMap": {"predicate": "($_self.isa<::mlir::AffineMapAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "lowerBoundsGroups": {"predicate": "(($_self.isa<::mlir::DenseIntElementsAttr>())) && (($_self.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ElementsAttrBase", "IntElementsAttrBase", "SignlessIntElementsAttr"], "kind": "predicate"}, "upperBoundsMap": {"predicate": "($_self.isa<::mlir::AffineMapAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "upperBoundsGroups": {"predicate": "(($_self.isa<::mlir::DenseIntElementsAttr>())) && (($_self.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ElementsAttrBase", "IntElementsAttrBase", "SignlessIntElementsAttr"], "kind": "predicate"}, "steps": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "results", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "affine", "traits": [{"name": "::mlir::OpTrait::SingleBlockImplicitTerminator<AffineYieldOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::HasRecursiveSideEffects", "kind": "native"}, {"name": "::mlir::OpTrait::MemRefsNormalizable", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "mapOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "affine.prefetch", "numResults": 0, "interfaces": ["AffineMapAccessInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"localityHint": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && (($_self.cast<::mlir::IntegerAttr>().getInt() >= 0)) && (($_self.cast<::mlir::IntegerAttr>().getInt() <= 3))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}, "isWrite": {"predicate": "($_self.isa<::mlir::BoolAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "isDataCache": {"predicate": "($_self.isa<::mlir::BoolAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 2, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "affine", "traits": [], "hasVerifier": true, "operands": [{"name": "memref", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "affine.store", "numResults": 0, "interfaces": ["AffineWriteOpInterface::Trait", "AffineMapAccessInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "affine", "traits": [{"name": "::mlir::OpTrait::MemRefsNormalizable", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "memref", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "affine.vector_load", "numResults": 1, "interfaces": ["AffineReadOpInterface::Trait", "AffineMapAccessInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "affine", "traits": [{"name": "::mlir::OpTrait::MemRefsNormalizable", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "memref", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "affine.vector_store", "numResults": 0, "interfaces": ["AffineWriteOpInterface::Trait", "AffineMapAccessInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "affine", "traits": [{"name": "::mlir::OpTrait::MemRefsNormalizable", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "(($_self.isa<::mlir::VectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "VectorOf"], "kind": "predicate"}}, {"name": "memref", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "affine.yield", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "affine", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}, {"name": "::mlir::OpTrait::ReturnLike", "kind": "native"}, {"name": "::mlir::OpTrait::MemRefsNormalizable", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [{"name": "emitc.apply", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"applicableOperator": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "emitc", "traits": [], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "emitc.call", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"callee": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}, "template_args": {"predicate": "($_self.isa<::mlir::ArrayAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "args": {"predicate": "($_self.isa<::mlir::ArrayAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "emitc", "traits": [], "hasVerifier": true, "operands": [{"name": "operands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "emitc.constant", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"value": {"predicate": "(true)", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "emitc", "traits": [{"name": "::mlir::OpTrait::ConstantLike", "kind": "native"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "emitc.include", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"include": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}, "is_standard_include": {"predicate": "($_self.isa<::mlir::UnitAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "emitc", "traits": [{"name": "::mlir::OpTrait::HasParent<ModuleOp>::Impl", "kind": "native"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}], "types": [{"name": "EmitC_OpaqueType", "cppName": "::mlir::Type", "numParameters": 1, "dialect": "emitc", "parameters": [{"name": "value", "cppType": "::llvm::StringRef"}], "hasVerifier": false, "traits": [], "interfaces": []}], "attrs": [{"name": "EmitC_OpaqueAttr", "cppName": "::mlir::Attribute", "numParameters": 1, "dialect": "emitc", "parameters": [{"name": "value", "cppType": "::llvm::StringRef"}], "hasVerifier": false, "traits": [], "interfaces": []}]}, {"ops": [], "types": [{"name": "EmitC_OpaqueType", "cppName": "::mlir::Type", "numParameters": 1, "dialect": "emitc", "parameters": [{"name": "value", "cppType": "::llvm::StringRef"}], "hasVerifier": false, "traits": [], "interfaces": []}], "attrs": []}, {"ops": [], "types": [], "attrs": [{"name": "EmitC_OpaqueAttr", "cppName": "::mlir::Attribute", "numParameters": 1, "dialect": "emitc", "parameters": [{"name": "value", "cppType": "::llvm::StringRef"}], "hasVerifier": false, "traits": [], "interfaces": []}]}, {"ops": [], "types": [], "attrs": []}, {"ops": [{"name": "arith.addf", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.addi", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.andi", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.bitcast", "numResults": 1, "interfaces": ["::mlir::CastOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "out", "constraint": {"predicate": "((($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))) || ((($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "((($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))) || ((($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.ceildivsi", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.cmpf", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"predicate": {"predicate": "($_self.isa<::mlir::arith::CmpFPredicateAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I64EnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"kind": "pred", "pred": "(std::equal_to<>()(::getI1SameShape($lhs.getType()), $result.getType()))"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.cmpi", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"predicate": {"predicate": "($_self.isa<::mlir::arith::CmpIPredicateAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I64EnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"kind": "pred", "pred": "(std::equal_to<>()(::getI1SameShape($lhs.getType()), $result.getType()))"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.constant", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"value": {"predicate": "(true)", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))) || ((($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::ConstantLike", "kind": "native"}, {"kind": "pred", "pred": "(std::equal_to<>()($value.getType(), $result.getType()))"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "arith.divf", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.divsi", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.divui", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.extf", "numResults": 1, "interfaces": ["::mlir::CastOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "out", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "in", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.extsi", "numResults": 1, "interfaces": ["::mlir::CastOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "out", "constraint": {"predicate": "(($_self.isSignlessInteger())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "in", "constraint": {"predicate": "(($_self.isSignlessInteger())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.extui", "numResults": 1, "interfaces": ["::mlir::CastOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "out", "constraint": {"predicate": "(($_self.isSignlessInteger())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "in", "constraint": {"predicate": "(($_self.isSignlessInteger())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.fptosi", "numResults": 1, "interfaces": ["::mlir::CastOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "out", "constraint": {"predicate": "(($_self.isSignlessInteger())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.fptoui", "numResults": 1, "interfaces": ["::mlir::CastOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "out", "constraint": {"predicate": "(($_self.isSignlessInteger())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.floordivsi", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.index_cast", "numResults": 1, "interfaces": ["::mlir::CastOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "out", "constraint": {"predicate": "(($_self.isSignlessInteger())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(($_self.isSignlessInteger())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.mulf", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.muli", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.negf", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.ori", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.remf", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.remsi", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.remui", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.sitofp", "numResults": 1, "interfaces": ["::mlir::CastOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "out", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(($_self.isSignlessInteger())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.shli", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.shrsi", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.shrui", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.subf", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.subi", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.truncf", "numResults": 1, "interfaces": ["::mlir::CastOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "out", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "in", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.trunci", "numResults": 1, "interfaces": ["::mlir::CastOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "out", "constraint": {"predicate": "(($_self.isSignlessInteger())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "in", "constraint": {"predicate": "(($_self.isSignlessInteger())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.uitofp", "numResults": 1, "interfaces": ["::mlir::CastOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "out", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(($_self.isSignlessInteger())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arith.xori", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arith", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [{"name": "rocdl.barrier", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "rocdl.workgroup.dim.x", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "rocdl.workgroup.dim.y", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "rocdl.workgroup.dim.z", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "rocdl.workgroup.id.x", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "rocdl.workgroup.id.y", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "rocdl.workgroup.id.z", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "rocdl.grid.dim.x", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "rocdl.grid.dim.y", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "rocdl.grid.dim.z", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "rocdl.buffer.load", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 5, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "rsrc", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "vindex", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "offset", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "glc", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "slc", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "rocdl.buffer.store", "numResults": 0, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 6, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "vdata", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "rsrc", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "vindex", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "offset", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "glc", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "slc", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "rocdl.workitem.id.x", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "rocdl.workitem.id.y", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "rocdl.workitem.id.z", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "rocdl.mfma.f32.16x16x16f16", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "rocdl.mfma.f32.16x16x1f32", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "rocdl.mfma.f32.16x16x2bf16", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "rocdl.mfma.f32.16x16x4f16", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "rocdl.mfma.f32.16x16x4f32", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "rocdl.mfma.f32.16x16x8bf16", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "rocdl.mfma.f32.32x32x1f32", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "rocdl.mfma.f32.32x32x2bf16", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "rocdl.mfma.f32.32x32x2f32", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "rocdl.mfma.f32.32x32x4bf16", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "rocdl.mfma.f32.32x32x4f16", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "rocdl.mfma.f32.32x32x8f16", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "rocdl.mfma.f32.4x4x1f32", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "rocdl.mfma.f32.4x4x2bf16", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "rocdl.mfma.f32.4x4x4f16", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "rocdl.mfma.i32.16x16x16i8", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "rocdl.mfma.i32.16x16x4i8", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "rocdl.mfma.i32.32x32x4i8", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "rocdl.mfma.i32.32x32x8i8", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "rocdl.mfma.i32.4x4x4i8", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "rocdl", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [{"name": "nvvm.barrier0", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "nvvm", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "nvvm.read.ptx.sreg.ntid.x", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "nvvm", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "nvvm.read.ptx.sreg.ntid.y", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "nvvm", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "nvvm.read.ptx.sreg.ntid.z", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "nvvm", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "nvvm.read.ptx.sreg.ctaid.x", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "nvvm", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "nvvm.read.ptx.sreg.ctaid.y", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "nvvm", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "nvvm.read.ptx.sreg.ctaid.z", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "nvvm", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "nvvm.read.ptx.sreg.nctaid.x", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "nvvm", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "nvvm.read.ptx.sreg.nctaid.y", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "nvvm", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "nvvm.read.ptx.sreg.nctaid.z", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "nvvm", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "nvvm.read.ptx.sreg.laneid", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "nvvm", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "nvvm.mma.sync", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "nvvm", "traits": [], "hasVerifier": true, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "nvvm.shfl.sync.bfly", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"return_value_and_is_valid": {"predicate": "($_self.isa<::mlir::UnitAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 4, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "nvvm", "traits": [], "hasVerifier": true, "operands": [{"name": "dst", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "val", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "offset", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "mask_and_clamp", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "nvvm.read.ptx.sreg.tid.x", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "nvvm", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "nvvm.read.ptx.sreg.tid.y", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "nvvm", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "nvvm.read.ptx.sreg.tid.z", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "nvvm", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "nvvm.vote.ballot.sync", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "nvvm", "traits": [], "hasVerifier": false, "operands": [{"name": "mask", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "pred", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "nvvm.wmma.m16n16k16.load.a.f16.row.stride", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMStructType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "nvvm", "traits": [], "hasVerifier": true, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "nvvm.wmma.m16n16k16.load.b.f16.row.stride", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMStructType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "nvvm", "traits": [], "hasVerifier": true, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "nvvm.wmma.m16n16k16.load.c.f16.row.stride", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMStructType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "nvvm", "traits": [], "hasVerifier": true, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "nvvm.wmma.m16n16k16.load.c.f32.row.stride", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMStructType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "nvvm", "traits": [], "hasVerifier": true, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "nvvm.wmma.m16n16k16.mma.row.row.f16.f16", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMStructType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "nvvm", "traits": [], "hasVerifier": true, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "nvvm.wmma.m16n16k16.mma.row.row.f32.f32", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMStructType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "nvvm", "traits": [], "hasVerifier": true, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "nvvm.wmma.m16n16k16.store.d.f16.row.stride", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "nvvm", "traits": [], "hasVerifier": true, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "nvvm.wmma.m16n16k16.store.d.f32.row.stride", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "nvvm", "traits": [], "hasVerifier": true, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "nvvm.read.ptx.sreg.warpsize", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "nvvm", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [{"name": "llvm.ashr", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.access_group", "numResults": 0, "interfaces": ["::mlir::SymbolOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"sym_name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::HasParent<MetadataOp>::Impl", "kind": "native"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "llvm.add", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.addrspacecast", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::LLVM::LLVMPointerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::LLVM::LLVMPointerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"predicate": "(($_self.isa<::mlir::LLVM::LLVMPointerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::LLVM::LLVMPointerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.mlir.addressof", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"global_name": {"predicate": "($_self.isa<::mlir::FlatSymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "llvm.alias_scope_domain", "numResults": 0, "interfaces": ["::mlir::SymbolOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"description": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "sym_name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::HasParent<MetadataOp>::Impl", "kind": "native"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "llvm.alias_scope", "numResults": 0, "interfaces": ["::mlir::SymbolOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"description": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "domain": {"predicate": "($_self.isa<::mlir::FlatSymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "sym_name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::HasParent<MetadataOp>::Impl", "kind": "native"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "llvm.alloca", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"alignment": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMPointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "arraySize", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.and", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.assume", "numResults": 0, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "cond", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.cmpxchg", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"failure_ordering": {"predicate": "($_self.isa<::mlir::LLVM::AtomicOrderingAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I64EnumAttr"], "kind": "predicate"}, "success_ordering": {"predicate": "($_self.isa<::mlir::LLVM::AtomicOrderingAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I64EnumAttr"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::LLVM::LLVMStructType>())) && (($_self.cast<::mlir::LLVM::LLVMStructType>().getBody().size() == 2)) && ((($_self.cast<::mlir::LLVM::LLVMStructType>().getBody()[0].isa<::mlir::IntegerType>())) || (($_self.cast<::mlir::LLVM::LLVMStructType>().getBody()[0].isa<::mlir::LLVM::LLVMPointerType>()))) && (($_self.cast<::mlir::LLVM::LLVMStructType>().getBody()[1].isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": true, "operands": [{"name": "ptr", "constraint": {"predicate": "(($_self.isa<::mlir::LLVM::LLVMPointerType>())) && ((($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType().isa<::mlir::IntegerType>())) || (($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType().isa<::mlir::LLVM::LLVMPointerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "LLVM_PointerTo"], "kind": "predicate"}}, {"name": "cmp", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (($_self.isa<::mlir::LLVM::LLVMPointerType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "val", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (($_self.isa<::mlir::LLVM::LLVMPointerType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.atomicrmw", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"bin_op": {"predicate": "($_self.isa<::mlir::LLVM::AtomicBinOpAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I64EnumAttr"], "kind": "predicate"}, "ordering": {"predicate": "($_self.isa<::mlir::LLVM::AtomicOrderingAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I64EnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (($_self.isa<::mlir::IntegerType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": true, "operands": [{"name": "ptr", "constraint": {"predicate": "(($_self.isa<::mlir::LLVM::LLVMPointerType>())) && (((::mlir::LLVM::isCompatibleFloatingPointType($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType()))) || (($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType().isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "LLVM_PointerTo"], "kind": "predicate"}}, {"name": "val", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (($_self.isa<::mlir::IntegerType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.bitreverse", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.bitcast", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleType($_self))) && (!(($_self.isa<::mlir::LLVM::LLVMStructType, ::mlir::LLVM::LLVMArrayType>())))", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleType($_self))) && (!(($_self.isa<::mlir::LLVM::LLVMStructType, ::mlir::LLVM::LLVMArrayType>())))", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.br", "numResults": 0, "interfaces": ["::mlir::BranchOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "destOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 1}, {"name": "llvm.call", "numResults": 1, "interfaces": ["::mlir::LLVM::FastmathFlagsInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"fastmathFlags": {"predicate": "($_self.isa<::mlir::LLVM::FMFAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "DefaultValuedAttr"], "kind": "predicate"}, "callee": {"predicate": "($_self.isa<::mlir::FlatSymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "llvm", "traits": [], "hasVerifier": true, "operands": [{"name": "", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "llvm.cond_br", "numResults": 0, "interfaces": ["::mlir::BranchOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"branch_weights": {"predicate": "($_self.isa<::mlir::ElementsAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 3, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 2, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "condition", "constraint": {"kind": "integer", "bitwidth": 1}}, {"name": "trueDestOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}, {"name": "falseDestOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 2}, {"name": "llvm.mlir.constant", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"value": {"predicate": "(true)", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "llvm.intr.copysign", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.coro.begin", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "token", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMTokenType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "mem", "constraint": {"predicate": "(($_self.isa<::mlir::LLVM::LLVMPointerType>())) && (($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType().isSignlessInteger(8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType", "LLVM_IntPtrBase"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.coro.end", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "handle", "constraint": {"predicate": "(($_self.isa<::mlir::LLVM::LLVMPointerType>())) && (($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType().isSignlessInteger(8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType", "LLVM_IntPtrBase"], "kind": "predicate"}}, {"name": "unwind", "constraint": {"kind": "integer", "bitwidth": 1}}], "numSuccessors": 0}, {"name": "llvm.intr.coro.free", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "id", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMTokenType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "handle", "constraint": {"predicate": "(($_self.isa<::mlir::LLVM::LLVMPointerType>())) && (($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType().isSignlessInteger(8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType", "LLVM_IntPtrBase"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.coro.id", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 4, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "align", "constraint": {"kind": "integer", "bitwidth": 32}}, {"name": "promise", "constraint": {"predicate": "(($_self.isa<::mlir::LLVM::LLVMPointerType>())) && (($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType().isSignlessInteger(8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType", "LLVM_IntPtrBase"], "kind": "predicate"}}, {"name": "coroaddr", "constraint": {"predicate": "(($_self.isa<::mlir::LLVM::LLVMPointerType>())) && (($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType().isSignlessInteger(8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType", "LLVM_IntPtrBase"], "kind": "predicate"}}, {"name": "fnaddrs", "constraint": {"predicate": "(($_self.isa<::mlir::LLVM::LLVMPointerType>())) && (($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType().isSignlessInteger(8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType", "LLVM_IntPtrBase"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.coro.resume", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "handle", "constraint": {"predicate": "(($_self.isa<::mlir::LLVM::LLVMPointerType>())) && (($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType().isSignlessInteger(8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType", "LLVM_IntPtrBase"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.coro.save", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "handle", "constraint": {"predicate": "(($_self.isa<::mlir::LLVM::LLVMPointerType>())) && (($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType().isSignlessInteger(8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType", "LLVM_IntPtrBase"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.coro.size", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "llvm.intr.coro.suspend", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "save", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMTokenType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "final", "constraint": {"kind": "integer", "bitwidth": 1}}], "numSuccessors": 0}, {"name": "llvm.intr.cos", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.ctpop", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.exp2", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.exp", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.extractelement", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": true, "operands": [{"name": "vector", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleVectorType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "position", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.extractvalue", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"position": {"predicate": "($_self.isa<::mlir::ArrayAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": true, "operands": [{"name": "container", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMStructType, ::mlir::LLVM::LLVMArrayType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.fabs", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.fadd", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::LLVM::FastmathFlagsInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"fastmathFlags": {"predicate": "($_self.isa<::mlir::LLVM::FMFAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "DefaultValuedAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.ceil", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.fcmp", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::LLVM::FastmathFlagsInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"predicate": {"predicate": "($_self.isa<::mlir::LLVM::FCmpPredicateAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I64EnumAttr"], "kind": "predicate"}, "fastmathFlags": {"predicate": "($_self.isa<::mlir::LLVM::FMFAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "DefaultValuedAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isSignlessInteger(1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.fdiv", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::LLVM::FastmathFlagsInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"fastmathFlags": {"predicate": "($_self.isa<::mlir::LLVM::FMFAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "DefaultValuedAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.floor", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.fma", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "c", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.fmuladd", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "c", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.fmul", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::LLVM::FastmathFlagsInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"fastmathFlags": {"predicate": "($_self.isa<::mlir::LLVM::FMFAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "DefaultValuedAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.fneg", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::LLVM::FastmathFlagsInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"fastmathFlags": {"predicate": "($_self.isa<::mlir::LLVM::FMFAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "DefaultValuedAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.fpext", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.fptosi", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.fptoui", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.fptrunc", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.frem", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::LLVM::FastmathFlagsInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"fastmathFlags": {"predicate": "($_self.isa<::mlir::LLVM::FMFAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "DefaultValuedAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.fsub", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::LLVM::FastmathFlagsInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"fastmathFlags": {"predicate": "($_self.isa<::mlir::LLVM::FMFAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "DefaultValuedAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.fence", "numResults": 0, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"syncscope": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}, "ordering": {"predicate": "($_self.isa<::mlir::LLVM::AtomicOrderingAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I64EnumAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "llvm.freeze", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "val", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.getelementptr", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::LLVM::LLVMPointerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::LLVM::LLVMPointerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "base", "constraint": {"predicate": "(($_self.isa<::mlir::LLVM::LLVMPointerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::LLVM::LLVMPointerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "llvm.intr.get.active.lane.mask", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "base", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "n", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.mlir.global", "numResults": 0, "interfaces": ["::mlir::SymbolOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {"dso_local": {"predicate": "($_self.isa<::mlir::UnitAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "type": {"predicate": "(($_self.isa<::mlir::TypeAttr>())) && (($_self.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypeAttrBase"], "kind": "predicate"}, "unnamed_addr": {"predicate": "($_self.isa<::mlir::LLVM::UnnamedAddrAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "section": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "addr_space": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((!$_self.cast<::mlir::IntegerAttr>().getValue().isNegative()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "DefaultValuedAttr"], "kind": "predicate"}, "sym_name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}, "constant": {"predicate": "($_self.isa<::mlir::UnitAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "linkage": {"predicate": "($_self.isa<::mlir::LLVM::LinkageAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "DialectAttr"], "kind": "predicate"}, "value": {"predicate": "(true)", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "alignment": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::IsIsolatedFromAbove", "kind": "native"}, {"name": "::mlir::OpTrait::SingleBlockImplicitTerminator<ReturnOp>::Impl", "kind": "native"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "llvm.icmp", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"predicate": {"predicate": "($_self.isa<::mlir::LLVM::ICmpPredicateAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I64EnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isSignlessInteger(1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "((($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))) || ((($_self.isa<::mlir::LLVM::LLVMPointerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::LLVM::LLVMPointerType>()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))) || ((($_self.isa<::mlir::LLVM::LLVMPointerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::LLVM::LLVMPointerType>()))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.inline_asm", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"asm_dialect": {"predicate": "($_self.isa<::mlir::LLVM::AsmDialectAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "asm_string": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}, "constraints": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}, "is_align_stack": {"predicate": "($_self.isa<::mlir::UnitAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "has_side_effects": {"predicate": "($_self.isa<::mlir::UnitAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "res", "constraint": {"kind": "optional", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "operands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "llvm.insertelement", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleVectorType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": true, "operands": [{"name": "vector", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleVectorType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "value", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleType($_self))) && ((!$_self.isa<::mlir::LLVM::LLVMVoidType, ::mlir::LLVM::LLVMFunctionType>()))", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "position", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.insertvalue", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"position": {"predicate": "($_self.isa<::mlir::ArrayAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMStructType, ::mlir::LLVM::LLVMArrayType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": true, "operands": [{"name": "container", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMStructType, ::mlir::LLVM::LLVMArrayType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "value", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleType($_self))) && ((!$_self.isa<::mlir::LLVM::LLVMVoidType, ::mlir::LLVM::LLVMFunctionType>()))", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.inttoptr", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::LLVM::LLVMPointerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::LLVM::LLVMPointerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.invoke", "numResults": 1, "interfaces": ["::mlir::BranchOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"callee": {"predicate": "($_self.isa<::mlir::FlatSymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 3, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}, {"name": "normalDestOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}, {"name": "unwindDestOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 2}, {"name": "llvm.func", "numResults": 0, "interfaces": ["::mlir::SymbolOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {"dso_local": {"predicate": "($_self.isa<::mlir::UnitAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "passthrough": {"predicate": "($_self.isa<::mlir::ArrayAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "personality": {"predicate": "($_self.isa<::mlir::FlatSymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "linkage": {"predicate": "($_self.isa<::mlir::LLVM::LinkageAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "DefaultValuedAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::AutomaticAllocationScope", "kind": "native"}, {"name": "::mlir::OpTrait::IsIsolatedFromAbove", "kind": "native"}, {"name": "::mlir::OpTrait::FunctionLike", "kind": "native"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "llvm.lshr", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.landingpad", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"cleanup": {"predicate": "($_self.isa<::mlir::UnitAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "llvm", "traits": [], "hasVerifier": true, "operands": [{"name": "", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "llvm.load", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"volatile_": {"predicate": "($_self.isa<::mlir::UnitAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "access_groups": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::SymbolRefAttr>()); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "nontemporal": {"predicate": "($_self.isa<::mlir::UnitAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "noalias_scopes": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::SymbolRefAttr>()); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "alias_scopes": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::SymbolRefAttr>()); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "alignment": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "((((::mlir::LLVM::isCompatibleType($_self))) && ((!$_self.isa<::mlir::LLVM::LLVMVoidType, ::mlir::LLVM::LLVMFunctionType>()))) && (!((($_self.isa<::mlir::LLVM::LLVMStructType>())) && (($_self.cast<::mlir::LLVM::LLVMStructType>().isOpaque()))))) || (($_self.isa<::mlir::LLVM::PointerElementTypeInterface>()))", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": true, "operands": [{"name": "addr", "constraint": {"predicate": "(($_self.isa<::mlir::LLVM::LLVMPointerType>())) && (((((::mlir::LLVM::isCompatibleType($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType()))) && ((!$_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType().isa<::mlir::LLVM::LLVMVoidType, ::mlir::LLVM::LLVMFunctionType>()))) && (!((($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType().isa<::mlir::LLVM::LLVMStructType>())) && (($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType().cast<::mlir::LLVM::LLVMStructType>().isOpaque()))))) || (($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType().isa<::mlir::LLVM::PointerElementTypeInterface>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "LLVM_PointerTo"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.log10", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.log2", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.log", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.masked.load", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"alignment": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "data", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "mask", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "pass_thru", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "llvm.intr.masked.store", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"alignment": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 3, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "value", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "data", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "mask", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.matrix.column.major.load", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"columns": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}, "rows": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}, "isVolatile": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(1)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "data", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "stride", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.matrix.column.major.store", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"columns": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}, "rows": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}, "isVolatile": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(1)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 3, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "matrix", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "data", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "stride", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.matrix.multiply", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"lhs_rows": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}, "lhs_columns": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}, "rhs_columns": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.matrix.transpose", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"columns": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}, "rows": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "matrix", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.maxnum", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.maximum", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.memcpy.inline", "numResults": 0, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 4, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "dst", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "src", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "len", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "isVolatile", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.memcpy", "numResults": 0, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 4, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "dst", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "src", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "len", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "isVolatile", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.metadata", "numResults": 0, "interfaces": ["::mlir::SymbolOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 1, "attributes": {"sym_name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::NoRegionArguments", "kind": "native"}, {"name": "::mlir::OpTrait::SymbolTable", "kind": "native"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "llvm.intr.minnum", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.minimum", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.mul", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.mlir.null", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMPointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "llvm.or", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.pow", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.prefetch", "numResults": 0, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 4, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "addr", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "rw", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "hint", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "cache", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.ptrtoint", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"predicate": "(($_self.isa<::mlir::LLVM::LLVMPointerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::LLVM::LLVMPointerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.resume", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.return", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "llvm.intr.sadd.with.overflow", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.sdiv", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.sext", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.sitofp", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.smax", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.smin", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.smul.with.overflow", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.srem", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.ssub.with.overflow", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.select", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$trueValue.getType(), $falseValue.getType(), $res.getType()})))"}], "hasVerifier": false, "operands": [{"name": "condition", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isSignlessInteger(1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "trueValue", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "falseValue", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.shl", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.shufflevector", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"mask": {"predicate": "($_self.isa<::mlir::ArrayAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleVectorType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": true, "operands": [{"name": "v1", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleVectorType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "v2", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleVectorType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.sin", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.sqrt", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.stackrestore", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "ptr", "constraint": {"predicate": "(($_self.isa<::mlir::LLVM::LLVMPointerType>())) && (($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType().isSignlessInteger(8)))", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType", "LLVM_IntPtrBase"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.stacksave", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "llvm.store", "numResults": 0, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"volatile_": {"predicate": "($_self.isa<::mlir::UnitAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "access_groups": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::SymbolRefAttr>()); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "nontemporal": {"predicate": "($_self.isa<::mlir::UnitAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "noalias_scopes": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::SymbolRefAttr>()); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "alias_scopes": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::SymbolRefAttr>()); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "alignment": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "((((::mlir::LLVM::isCompatibleType($_self))) && ((!$_self.isa<::mlir::LLVM::LLVMVoidType, ::mlir::LLVM::LLVMFunctionType>()))) && (!((($_self.isa<::mlir::LLVM::LLVMStructType>())) && (($_self.cast<::mlir::LLVM::LLVMStructType>().isOpaque()))))) || (($_self.isa<::mlir::LLVM::PointerElementTypeInterface>()))", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "addr", "constraint": {"predicate": "(($_self.isa<::mlir::LLVM::LLVMPointerType>())) && (((((::mlir::LLVM::isCompatibleType($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType()))) && ((!$_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType().isa<::mlir::LLVM::LLVMVoidType, ::mlir::LLVM::LLVMFunctionType>()))) && (!((($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType().isa<::mlir::LLVM::LLVMStructType>())) && (($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType().cast<::mlir::LLVM::LLVMStructType>().isOpaque()))))) || (($_self.cast<::mlir::LLVM::LLVMPointerType>().getElementType().isa<::mlir::LLVM::PointerElementTypeInterface>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "LLVM_PointerTo"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.sub", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.switch", "numResults": 0, "interfaces": ["::mlir::BranchOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"branch_weights": {"predicate": "($_self.isa<::mlir::ElementsAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "case_operand_segments": {"predicate": "($_self.isa<::mlir::ElementsAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "ElementsAttrBase"], "kind": "predicate"}, "case_values": {"predicate": "($_self.isa<::mlir::ElementsAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 3, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 2, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"kind": "integer", "bitwidth": 32}}, {"name": "defaultOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}, {"name": "caseOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 2}, {"name": "llvm.trunc", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.uadd.with.overflow", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.udiv", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.uitofp", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "((::mlir::LLVM::isCompatibleFloatingPointType($_self))) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::isCompatibleFloatingPointType(::mlir::LLVM::getVectorElementType($_self)))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.umul.with.overflow", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.urem", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.usub.with.overflow", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.mlir.undef", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "llvm.unreachable", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "llvm.xor", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.zext", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"predicate": "(($_self.isa<::mlir::IntegerType>())) || (((::mlir::LLVM::isCompatibleVectorType($_self))) && ((::mlir::LLVM::getVectorElementType($_self).isa<::mlir::IntegerType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "LLVM_ScalarOrVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.masked.compressstore", "numResults": 0, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.masked.expandload", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.masked.gather", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"alignment": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "ptrs", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "mask", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "pass_thru", "constraint": {"kind": "variadic", "baseType": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "llvm.intr.masked.scatter", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"alignment": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 3, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "value", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "ptrs", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "mask", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.vector.reduce.add", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.vector.reduce.and", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.vector.reduce.fadd", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"reassoc": {"predicate": "($_self.isa<::mlir::BoolAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "DefaultValuedAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.vector.reduce.fmax", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.vector.reduce.fmin", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.vector.reduce.fmul", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"reassoc": {"predicate": "($_self.isa<::mlir::BoolAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "DefaultValuedAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.vector.reduce.mul", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.vector.reduce.or", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.vector.reduce.smax", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.vector.reduce.smin", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.vector.reduce.umax", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.vector.reduce.umin", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "llvm.intr.vector.reduce.xor", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "llvm", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": [{"name": "FastmathFlagsAttr", "cppName": "::mlir::Attribute", "numParameters": 1, "dialect": "llvm", "parameters": [{"name": "flags", "cppType": "FastmathFlags"}], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "LinkageAttr", "cppName": "::mlir::Attribute", "numParameters": 1, "dialect": "llvm", "parameters": [{"name": "linkage", "cppType": "linkage::Linkage"}], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "LoopOptionsAttr", "cppName": "::mlir::Attribute", "numParameters": 1, "dialect": "llvm", "parameters": [{"name": "options", "cppType": "::llvm::ArrayRef<std::pair<LoopOptionCase, int64_t>>"}], "hasVerifier": false, "traits": [], "interfaces": []}]}, {"ops": [{"name": "pdl.apply_native_constraint", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}, "constParams": {"predicate": "($_self.isa<::mlir::ArrayAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "pdl", "traits": [{"name": "::mlir::OpTrait::HasParent<pdl::PatternOp>::Impl", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::pdl::PDLType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "pdl.apply_native_rewrite", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}, "constParams": {"predicate": "($_self.isa<::mlir::ArrayAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "results", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::pdl::PDLType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "pdl", "traits": [{"name": "::mlir::OpTrait::HasParent<pdl::RewriteOp>::Impl", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::pdl::PDLType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "pdl.attribute", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"value": {"predicate": "(true)", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "attr", "constraint": {"name": "PDL_Attribute", "dialect": "pdl", "kind": "typeDef"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "pdl", "traits": [], "hasVerifier": true, "operands": [{"name": "type", "constraint": {"kind": "optional", "baseType": {"name": "PDL_Type", "dialect": "pdl", "kind": "typeDef"}}}], "numSuccessors": 0}, {"name": "pdl.erase", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl", "traits": [{"name": "::mlir::OpTrait::HasParent<pdl::RewriteOp>::Impl", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operation", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "pdl.operand", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "val", "constraint": {"name": "PDL_Value", "dialect": "pdl", "kind": "typeDef"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "pdl", "traits": [{"name": "::mlir::OpTrait::HasParent<pdl::PatternOp>::Impl", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "type", "constraint": {"kind": "optional", "baseType": {"name": "PDL_Type", "dialect": "pdl", "kind": "typeDef"}}}], "numSuccessors": 0}, {"name": "pdl.operands", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "val", "constraint": {"predicate": "(($_self.isa<::mlir::pdl::RangeType>())) && (($_self.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::ValueType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "BuildableType", "PDL_RangeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "pdl", "traits": [{"name": "::mlir::OpTrait::HasParent<pdl::PatternOp>::Impl", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "type", "constraint": {"kind": "optional", "baseType": {"predicate": "(($_self.isa<::mlir::pdl::RangeType>())) && (($_self.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::TypeType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "BuildableType", "PDL_RangeOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "pdl.operation", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "attributeNames": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::StringAttr>()); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "op", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 3, "dialect": "pdl", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::pdl::ValueType>())) || ((($_self.isa<::mlir::pdl::RangeType>())) && (($_self.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::ValueType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "PDL_InstOrRangeOf"], "kind": "predicate"}}}, {"name": "attributes", "constraint": {"kind": "variadic", "baseType": {"name": "PDL_Attribute", "dialect": "pdl", "kind": "typeDef"}}}, {"name": "types", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::pdl::TypeType>())) || ((($_self.isa<::mlir::pdl::RangeType>())) && (($_self.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::TypeType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "PDL_InstOrRangeOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "pdl.pattern", "numResults": 0, "interfaces": ["::mlir::SymbolOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 1, "attributes": {"sym_name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "rootKind": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "benefit": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(16)))) && ((!$_self.cast<::mlir::IntegerAttr>().getValue().isNegative()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl", "traits": [{"name": "::mlir::OpTrait::IsIsolatedFromAbove", "kind": "native"}, {"name": "::mlir::OpTrait::SingleBlock", "kind": "native"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "pdl.replace", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 2, "dialect": "pdl", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}, {"name": "::mlir::OpTrait::HasParent<pdl::RewriteOp>::Impl", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operation", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}, {"name": "replOperation", "constraint": {"kind": "optional", "baseType": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}}, {"name": "replValues", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::pdl::ValueType>())) || ((($_self.isa<::mlir::pdl::RangeType>())) && (($_self.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::ValueType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "PDL_InstOrRangeOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "pdl.result", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"index": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase", "SignlessIntegerAttrBase", "TypedSignlessIntegerAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "val", "constraint": {"name": "PDL_Value", "dialect": "pdl", "kind": "typeDef"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl", "traits": [], "hasVerifier": false, "operands": [{"name": "parent", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "pdl.results", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"index": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "val", "constraint": {"predicate": "(($_self.isa<::mlir::pdl::ValueType>())) || ((($_self.isa<::mlir::pdl::RangeType>())) && (($_self.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::ValueType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "PDL_InstOrRangeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl", "traits": [], "hasVerifier": true, "operands": [{"name": "parent", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "pdl.rewrite", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 1, "attributes": {"name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "externalConstParams": {"predicate": "($_self.isa<::mlir::ArrayAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "pdl", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}, {"name": "::mlir::OpTrait::HasParent<pdl::PatternOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::NoTerminator", "kind": "native"}, {"name": "::mlir::OpTrait::NoRegionArguments", "kind": "native"}, {"name": "::mlir::OpTrait::SingleBlock", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "root", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}, {"name": "externalArgs", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::pdl::PDLType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "pdl.type", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"type": {"predicate": "(($_self.isa<::mlir::TypeAttr>())) && (($_self.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "result", "constraint": {"name": "PDL_Type", "dialect": "pdl", "kind": "typeDef"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "pdl.types", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"types": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::pdl::RangeType>())) && (($_self.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::TypeType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "BuildableType", "PDL_RangeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}], "types": [{"name": "PDL_Attribute", "cppName": "::mlir::pdl::PDLType", "numParameters": 0, "dialect": "pdl", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "PDL_Operation", "cppName": "::mlir::pdl::PDLType", "numParameters": 0, "dialect": "pdl", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "PDL_Range", "cppName": "::mlir::pdl::PDLType", "numParameters": 1, "dialect": "pdl", "parameters": [{"name": "elementType", "cppType": "Type"}], "hasVerifier": true, "traits": [], "interfaces": []}, {"name": "PDL_Type", "cppName": "::mlir::pdl::PDLType", "numParameters": 0, "dialect": "pdl", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "PDL_Value", "cppName": "::mlir::pdl::PDLType", "numParameters": 0, "dialect": "pdl", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}], "attrs": []}, {"ops": [], "types": [{"name": "PDL_Attribute", "cppName": "::mlir::pdl::PDLType", "numParameters": 0, "dialect": "pdl", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "PDL_Operation", "cppName": "::mlir::pdl::PDLType", "numParameters": 0, "dialect": "pdl", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "PDL_Range", "cppName": "::mlir::pdl::PDLType", "numParameters": 1, "dialect": "pdl", "parameters": [{"name": "elementType", "cppType": "Type"}], "hasVerifier": true, "traits": [], "interfaces": []}, {"name": "PDL_Type", "cppName": "::mlir::pdl::PDLType", "numParameters": 0, "dialect": "pdl", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "PDL_Value", "cppName": "::mlir::pdl::PDLType", "numParameters": 0, "dialect": "pdl", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [{"name": "pdl_interp.apply_constraint", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}, "constParams": {"predicate": "($_self.isa<::mlir::ArrayAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "pdl_interp", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::pdl::PDLType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 2}, {"name": "pdl_interp.apply_rewrite", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}, "constParams": {"predicate": "($_self.isa<::mlir::ArrayAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "results", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::pdl::PDLType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "pdl_interp", "traits": [], "hasVerifier": false, "operands": [{"name": "args", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::pdl::PDLType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "pdl_interp.are_equal", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}, {"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "($_self.isa<::mlir::pdl::PDLType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "($_self.isa<::mlir::pdl::PDLType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 2}, {"name": "pdl_interp.branch", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [], "numSuccessors": 1}, {"name": "pdl_interp.check_attribute", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"constantValue": {"predicate": "(true)", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "attribute", "constraint": {"name": "PDL_Attribute", "dialect": "pdl", "kind": "typeDef"}}], "numSuccessors": 2}, {"name": "pdl_interp.check_operand_count", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"compareAtLeast": {"predicate": "($_self.isa<::mlir::UnitAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "count": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((!$_self.cast<::mlir::IntegerAttr>().getValue().isNegative()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operation", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}], "numSuccessors": 2}, {"name": "pdl_interp.check_operation_name", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operation", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}], "numSuccessors": 2}, {"name": "pdl_interp.check_result_count", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"compareAtLeast": {"predicate": "($_self.isa<::mlir::UnitAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "count": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((!$_self.cast<::mlir::IntegerAttr>().getValue().isNegative()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operation", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}], "numSuccessors": 2}, {"name": "pdl_interp.check_type", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"type": {"predicate": "(($_self.isa<::mlir::TypeAttr>())) && (($_self.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypeAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "value", "constraint": {"name": "PDL_Type", "dialect": "pdl", "kind": "typeDef"}}], "numSuccessors": 2}, {"name": "pdl_interp.check_types", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"types": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "value", "constraint": {"predicate": "(($_self.isa<::mlir::pdl::RangeType>())) && (($_self.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::TypeType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "BuildableType", "PDL_RangeOf"], "kind": "predicate"}}], "numSuccessors": 2}, {"name": "pdl_interp.create_attribute", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"value": {"predicate": "(true)", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "attribute", "constraint": {"name": "PDL_Attribute", "dialect": "pdl", "kind": "typeDef"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "pdl_interp.create_operation", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}, "attributeNames": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::StringAttr>()); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "operation", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 3, "dialect": "pdl_interp", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::pdl::ValueType>())) || ((($_self.isa<::mlir::pdl::RangeType>())) && (($_self.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::ValueType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "PDL_InstOrRangeOf"], "kind": "predicate"}}}, {"name": "attributes", "constraint": {"kind": "variadic", "baseType": {"name": "PDL_Attribute", "dialect": "pdl", "kind": "typeDef"}}}, {"name": "types", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::pdl::TypeType>())) || ((($_self.isa<::mlir::pdl::RangeType>())) && (($_self.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::TypeType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "PDL_InstOrRangeOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "pdl_interp.create_type", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"value": {"predicate": "(($_self.isa<::mlir::TypeAttr>())) && (($_self.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypeAttrBase"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "result", "constraint": {"name": "PDL_Type", "dialect": "pdl", "kind": "typeDef"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "pdl_interp.create_types", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"value": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::pdl::RangeType>())) && (($_self.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::TypeType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "BuildableType", "PDL_RangeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "pdl_interp.erase", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [], "hasVerifier": false, "operands": [{"name": "operation", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "pdl_interp.finalize", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "pdl_interp.get_attribute", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"name": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "attribute", "constraint": {"name": "PDL_Attribute", "dialect": "pdl", "kind": "typeDef"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [], "hasVerifier": false, "operands": [{"name": "operation", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "pdl_interp.get_attribute_type", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"name": "PDL_Type", "dialect": "pdl", "kind": "typeDef"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [], "hasVerifier": false, "operands": [{"name": "value", "constraint": {"name": "PDL_Attribute", "dialect": "pdl", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "pdl_interp.get_defining_op", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "operation", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [], "hasVerifier": false, "operands": [{"name": "value", "constraint": {"predicate": "(($_self.isa<::mlir::pdl::ValueType>())) || ((($_self.isa<::mlir::pdl::RangeType>())) && (($_self.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::ValueType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "PDL_InstOrRangeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "pdl_interp.get_operand", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"index": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((!$_self.cast<::mlir::IntegerAttr>().getValue().isNegative()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "value", "constraint": {"name": "PDL_Value", "dialect": "pdl", "kind": "typeDef"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [], "hasVerifier": false, "operands": [{"name": "operation", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "pdl_interp.get_operands", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"index": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((!$_self.cast<::mlir::IntegerAttr>().getValue().isNegative()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "value", "constraint": {"predicate": "(($_self.isa<::mlir::pdl::ValueType>())) || ((($_self.isa<::mlir::pdl::RangeType>())) && (($_self.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::ValueType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "PDL_InstOrRangeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [], "hasVerifier": false, "operands": [{"name": "operation", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "pdl_interp.get_result", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"index": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((!$_self.cast<::mlir::IntegerAttr>().getValue().isNegative()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "value", "constraint": {"name": "PDL_Value", "dialect": "pdl", "kind": "typeDef"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [], "hasVerifier": false, "operands": [{"name": "operation", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "pdl_interp.get_results", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"index": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((!$_self.cast<::mlir::IntegerAttr>().getValue().isNegative()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "value", "constraint": {"predicate": "(($_self.isa<::mlir::pdl::ValueType>())) || ((($_self.isa<::mlir::pdl::RangeType>())) && (($_self.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::ValueType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "PDL_InstOrRangeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [], "hasVerifier": false, "operands": [{"name": "operation", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "pdl_interp.get_value_type", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::pdl::TypeType>())) || ((($_self.isa<::mlir::pdl::RangeType>())) && (($_self.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::TypeType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "PDL_InstOrRangeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()(getGetValueTypeOpValueType($result.getType()), $value.getType()))"}], "hasVerifier": false, "operands": [{"name": "value", "constraint": {"predicate": "(($_self.isa<::mlir::pdl::ValueType>())) || ((($_self.isa<::mlir::pdl::RangeType>())) && (($_self.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::ValueType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "PDL_InstOrRangeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "pdl_interp.inferred_types", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "type", "constraint": {"predicate": "(($_self.isa<::mlir::pdl::RangeType>())) && (($_self.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::TypeType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "BuildableType", "PDL_RangeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "pdl_interp.is_not_null", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "value", "constraint": {"predicate": "($_self.isa<::mlir::pdl::PDLType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 2}, {"name": "pdl_interp.record_match", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"generatedOps": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::StringAttr>()); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "rewriter": {"predicate": "($_self.isa<::mlir::SymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "rootKind": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "benefit": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(16)))) && ((!$_self.cast<::mlir::IntegerAttr>().getValue().isNegative()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}}, "numOperands": 2, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 2, "dialect": "pdl_interp", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "inputs", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::pdl::PDLType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}, {"name": "matchedOps", "constraint": {"kind": "variadic", "baseType": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}}], "numSuccessors": 1}, {"name": "pdl_interp.replace", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "pdl_interp", "traits": [], "hasVerifier": false, "operands": [{"name": "operation", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}, {"name": "replValues", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::pdl::ValueType>())) || ((($_self.isa<::mlir::pdl::RangeType>())) && (($_self.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::ValueType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf", "PDL_InstOrRangeOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "pdl_interp.switch_attribute", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"caseValues": {"predicate": "($_self.isa<::mlir::ArrayAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "attribute", "constraint": {"name": "PDL_Attribute", "dialect": "pdl", "kind": "typeDef"}}], "numSuccessors": 2}, {"name": "pdl_interp.switch_operand_count", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"caseValues": {"predicate": "(($_self.isa<::mlir::DenseIntElementsAttr>())) && (($_self.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ElementsAttrBase", "IntElementsAttrBase", "SignlessIntElementsAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operation", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}], "numSuccessors": 2}, {"name": "pdl_interp.switch_operation_name", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"caseValues": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::StringAttr>()); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operation", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}], "numSuccessors": 2}, {"name": "pdl_interp.switch_result_count", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"caseValues": {"predicate": "(($_self.isa<::mlir::DenseIntElementsAttr>())) && (($_self.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ElementsAttrBase", "IntElementsAttrBase", "SignlessIntElementsAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operation", "constraint": {"name": "PDL_Operation", "dialect": "pdl", "kind": "typeDef"}}], "numSuccessors": 2}, {"name": "pdl_interp.switch_type", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"caseValues": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"name": "PDL_Type", "dialect": "pdl", "kind": "typeDef"}}], "numSuccessors": 2}, {"name": "pdl_interp.switch_types", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"caseValues": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(attr.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); })); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "pdl_interp", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "(($_self.isa<::mlir::pdl::RangeType>())) && (($_self.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::TypeType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "BuildableType", "PDL_RangeOf"], "kind": "predicate"}}], "numSuccessors": 2}], "types": [{"name": "PDL_Attribute", "cppName": "::mlir::pdl::PDLType", "numParameters": 0, "dialect": "pdl", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "PDL_Operation", "cppName": "::mlir::pdl::PDLType", "numParameters": 0, "dialect": "pdl", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "PDL_Range", "cppName": "::mlir::pdl::PDLType", "numParameters": 1, "dialect": "pdl", "parameters": [{"name": "elementType", "cppType": "Type"}], "hasVerifier": true, "traits": [], "interfaces": []}, {"name": "PDL_Type", "cppName": "::mlir::pdl::PDLType", "numParameters": 0, "dialect": "pdl", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "PDL_Value", "cppName": "::mlir::pdl::PDLType", "numParameters": 0, "dialect": "pdl", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [{"name": "shape.add", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::IndexType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::IndexType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::IndexType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "shape.any", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::shape::ShapeType>())) || (((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "shape", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "inputs", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::shape::ShapeType>())) || (((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "shape.assuming_all", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::shape::WitnessType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "shape", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "inputs", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::shape::WitnessType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "shape.assuming", "numResults": 1, "interfaces": ["::mlir::RegionBranchOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {}, "numOperands": 1, "results": [{"name": "results", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [{"name": "::mlir::OpTrait::SingleBlockImplicitTerminator<AssumingYieldOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::HasRecursiveSideEffects", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "witness", "constraint": {"predicate": "($_self.isa<::mlir::shape::WitnessType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "shape.assuming_yield", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "shape", "traits": [{"name": "::mlir::OpTrait::ReturnLike", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}, {"name": "::mlir::OpTrait::HasParent<AssumingOp>::Impl", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "shape.broadcast", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"error": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::shape::ShapeType>())) || (((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "shape", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "shapes", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::shape::ShapeType>())) || (((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "shape.concat", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::shape::ShapeType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "($_self.isa<::mlir::shape::ShapeType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "($_self.isa<::mlir::shape::ShapeType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "shape.const_shape", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"shape": {"predicate": "(($_self.isa<::mlir::DenseIntElementsAttr>())) && (($_self.cast<::mlir::DenseIntElementsAttr>()                                       .getType()                                       .getElementType()                                       .isIndex()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ElementsAttrBase", "IntElementsAttrBase"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::shape::ShapeType>())) || (((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [{"name": "::mlir::OpTrait::ConstantLike", "kind": "native"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "shape.const_size", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::OpAsmOpInterface::Trait", "::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"value": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isa<::mlir::IndexType>()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::shape::SizeType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [{"name": "::mlir::OpTrait::ConstantLike", "kind": "native"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "shape.const_witness", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"passing": {"predicate": "($_self.isa<::mlir::BoolAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::shape::WitnessType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [{"name": "::mlir::OpTrait::ConstantLike", "kind": "native"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "shape.cstr_broadcastable", "numResults": 1, "interfaces": ["::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::shape::WitnessType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "shape", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "shapes", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::shape::ShapeType>())) || (((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "shape.cstr_eq", "numResults": 1, "interfaces": ["::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::shape::WitnessType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "shape", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "shapes", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::shape::ShapeType>())) || (((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "shape.cstr_require", "numResults": 1, "interfaces": ["::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"msg": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::shape::WitnessType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [], "hasVerifier": false, "operands": [{"name": "pred", "constraint": {"kind": "integer", "bitwidth": 1}}], "numSuccessors": 0}, {"name": "shape.debug_print", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "output", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::shape::ShapeType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::shape::ShapeType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "shape.div", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::IndexType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [], "hasVerifier": true, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::IndexType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::IndexType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "shape.from_extent_tensor", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::shape::ShapeType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "TensorRankOf", "1DTensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "shape.from_extents", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "shape", "constraint": {"predicate": "($_self.isa<::mlir::shape::ShapeType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "shape", "traits": [], "hasVerifier": false, "operands": [{"name": "extents", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::IndexType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "shape.function_library", "numResults": 0, "interfaces": ["::mlir::SymbolOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {"mapping": {"predicate": "($_self.isa<::mlir::DictionaryAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "DictionaryAttrBase"], "kind": "predicate"}}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [{"name": "::mlir::OpTrait::AffineScope", "kind": "native"}, {"name": "::mlir::OpTrait::IsIsolatedFromAbove", "kind": "native"}, {"name": "::mlir::OpTrait::NoRegionArguments", "kind": "native"}, {"name": "::mlir::OpTrait::SymbolTable", "kind": "native"}, {"name": "::mlir::OpTrait::NoTerminator", "kind": "native"}, {"name": "::mlir::OpTrait::SingleBlock", "kind": "native"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "shape.get_extent", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "extent", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::IndexType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [], "hasVerifier": true, "operands": [{"name": "shape", "constraint": {"predicate": "(($_self.isa<::mlir::shape::ShapeType>())) || (((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "dim", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::IndexType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "shape.index_to_size", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::shape::SizeType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "shape.is_broadcastable", "numResults": 1, "interfaces": ["::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"kind": "integer", "bitwidth": 1}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "shape", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "shapes", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::shape::ShapeType>())) || (((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "shape.max", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::shape::ShapeType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::shape::ShapeType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::shape::ShapeType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "shape.meet", "numResults": 1, "interfaces": ["::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"error": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::shape::ShapeType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "arg0", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::shape::ShapeType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "arg1", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::shape::ShapeType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "shape.min", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::shape::ShapeType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::shape::ShapeType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::shape::ShapeType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "shape.mul", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::IndexType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::IndexType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::IndexType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "shape.num_elements", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::IndexType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [], "hasVerifier": true, "operands": [{"name": "shape", "constraint": {"predicate": "(($_self.isa<::mlir::shape::ShapeType>())) || (((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "shape.rank", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "rank", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::IndexType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [], "hasVerifier": true, "operands": [{"name": "shape", "constraint": {"predicate": "(($_self.isa<::mlir::shape::ShapeType>())) || (((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "shape.reduce", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "shape", "traits": [{"name": "::mlir::OpTrait::SingleBlockImplicitTerminator<YieldOp>::Impl", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "shape", "constraint": {"predicate": "(($_self.isa<::mlir::shape::ShapeType>())) || (((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "initVals", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "shape.shape_eq", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"kind": "integer", "bitwidth": 1}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "shape", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "shapes", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::shape::ShapeType>())) || (((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "shape.shape_of", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::shape::ShapeType>())) || (((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [], "hasVerifier": true, "operands": [{"name": "arg", "constraint": {"predicate": "((($_self.isa<::mlir::ShapedType>())) && ((true))) || (($_self.isa<::mlir::shape::ValueShapeType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "shape.size_to_index", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::IndexType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "shape.split_at", "numResults": 2, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "head", "constraint": {"predicate": "(($_self.isa<::mlir::shape::ShapeType>())) || (((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "tail", "constraint": {"predicate": "(($_self.isa<::mlir::shape::ShapeType>())) || (((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::shape::ShapeType>())) || (((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "index", "constraint": {"predicate": "(($_self.isa<::mlir::shape::SizeType>())) || (($_self.isa<::mlir::IndexType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "shape.to_extent_tensor", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [], "hasVerifier": false, "operands": [{"name": "input", "constraint": {"predicate": "(($_self.isa<::mlir::shape::ShapeType>())) || (((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1))))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "shape.with_shape", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::shape::ValueShapeType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "shape", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "((($_self.isa<::mlir::ShapedType>())) && ((true))) || (($_self.isa<::mlir::shape::ValueShapeType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "shape", "constraint": {"predicate": "($_self.isa<::mlir::shape::ShapeType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "shape.yield", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "shape", "traits": [{"name": "::mlir::OpTrait::HasParent<ReduceOp, FunctionLibraryOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::ReturnLike", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [{"name": "linalg.index", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"dim": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))) && (($_self.cast<::mlir::IntegerAttr>().getInt() >= 0))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "linalg", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "linalg.init_tensor", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::ReifyRankedShapedTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"static_sizes": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "linalg", "traits": [], "hasVerifier": true, "operands": [{"name": "sizes", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "linalg.pad_tensor", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::ReifyRankedShapedTypeOpInterface::Trait", "::mlir::TilingInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 1, "attributes": {"nofold": {"predicate": "($_self.isa<::mlir::UnitAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "static_high": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "static_low": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 2, "dialect": "linalg", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "source", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "low", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "high", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "linalg.range", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "", "constraint": {"predicate": "($_self.isa<RangeType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "linalg", "traits": [], "hasVerifier": false, "operands": [{"name": "min", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "max", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "step", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "linalg.tensor_collapse_shape", "numResults": 1, "interfaces": ["::mlir::ReifyRankedShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"reassociation": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(attr.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "linalg", "traits": [], "hasVerifier": true, "operands": [{"name": "src", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "linalg.tensor_expand_shape", "numResults": 1, "interfaces": ["::mlir::ReifyRankedShapedTypeOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"reassociation": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(attr.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "linalg", "traits": [], "hasVerifier": true, "operands": [{"name": "src", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "linalg.tiled_loop", "numResults": 1, "interfaces": ["::mlir::LoopLikeOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {"distribution_types": {"predicate": "($_self.isa<::mlir::ArrayAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}, "iterator_types": {"predicate": "($_self.isa<::mlir::ArrayAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase"], "kind": "predicate"}}, "numOperands": 5, "results": [{"name": "results", "constraint": {"kind": "variadic", "baseType": {"predicate": "((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().hasRank()))) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "RankedTensorOf"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 5, "dialect": "linalg", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}, {"name": "::mlir::OpTrait::HasRecursiveSideEffects", "kind": "native"}, {"name": "::mlir::OpTrait::SingleBlockImplicitTerminator<linalg::YieldOp>::Impl", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "lowerBound", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "upperBound", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "step", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "inputs", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}, {"name": "outputs", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::ShapedType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "linalg.yield", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "linalg", "traits": [{"name": "::mlir::OpTrait::ReturnLike", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "values", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [{"name": "std.absf", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.addf", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.addi", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.and", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.assert", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"msg": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [], "hasVerifier": false, "operands": [{"name": "arg", "constraint": {"kind": "integer", "bitwidth": 1}}], "numSuccessors": 0}, {"name": "std.atomic_rmw", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"kind": {"predicate": "($_self.isa<::mlir::AtomicRMWKindAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I64EnumAttr"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "std", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$value.getType(), $result.getType()})))"}, {"kind": "pred", "pred": "(std::equal_to<>()($memref.getType().cast<MemRefType>().getElementType(), $value.getType()))"}], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "memref", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "std.atomic_yield", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::HasParent<GenericAtomicRMWOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.bitcast", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::CastOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "out", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.br", "numResults": 0, "interfaces": ["::mlir::BranchOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "destOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 1}, {"name": "std.call_indirect", "numResults": 1, "interfaces": ["::mlir::CallOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "results", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "std", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()($callee.getType().cast<FunctionType>().getInputs(), $operands.getType()))"}, {"kind": "pred", "pred": "(std::equal_to<>()($callee.getType().cast<FunctionType>().getResults(), $results.getType()))"}], "hasVerifier": false, "operands": [{"name": "callee", "constraint": {"predicate": "($_self.isa<::mlir::FunctionType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "operands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "std.call", "numResults": 1, "interfaces": ["::mlir::CallOpInterface::Trait", "::mlir::SymbolUserOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"callee": {"predicate": "($_self.isa<::mlir::FlatSymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::MemRefsNormalizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "std.ceilf", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.cmpf", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"predicate": {"predicate": "($_self.isa<::mlir::CmpFPredicateAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I64EnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"kind": "pred", "pred": "(std::equal_to<>()(getI1SameShape($lhs.getType()), $result.getType()))"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.cmpi", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"predicate": {"predicate": "($_self.isa<::mlir::CmpIPredicateAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I64EnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"kind": "pred", "pred": "(std::equal_to<>()(getI1SameShape($lhs.getType()), $result.getType()))"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.cond_br", "numResults": 0, "interfaces": ["::mlir::BranchOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 2, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "condition", "constraint": {"kind": "integer", "bitwidth": 1}}, {"name": "trueDestOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}, {"name": "falseDestOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 2}, {"name": "std.constant", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::OpAsmOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"value": {"predicate": "(true)", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::ConstantLike", "kind": "native"}], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "std.copysign", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.divf", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.fpext", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::CastOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "out", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.fptosi", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::CastOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "out", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.fptoui", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::CastOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "out", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.fptrunc", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::CastOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "out", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.floorf", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.fmaf", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "a", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "b", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "c", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.generic_atomic_rmw", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SingleBlockImplicitTerminator<AtomicYieldOp>::Impl", "kind": "native"}, {"kind": "pred", "pred": "(std::equal_to<>()($memref.getType().cast<MemRefType>().getElementType(), $result.getType()))"}], "hasVerifier": true, "operands": [{"name": "memref", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "std.index_cast", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::CastOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "out", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.maxf", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.maxsi", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.maxui", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.minf", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.minsi", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.minui", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.mulf", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.muli", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.negf", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.or", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.rank", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [], "hasVerifier": false, "operands": [{"name": "memrefOrTensor", "constraint": {"predicate": "(((($_self.isa<::mlir::UnrankedMemRefType>())) && ((true))) || ((($_self.isa<::mlir::MemRefType>())) && ((true)))) || ((($_self.isa<::mlir::TensorType>())) && ((true)))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.remf", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.return", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::HasParent<FuncOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::MemRefsNormalizable", "kind": "native"}, {"name": "::mlir::OpTrait::ReturnLike", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "std.sitofp", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::CastOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "out", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.select", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$true_value.getType(), $false_value.getType(), $result.getType()})))"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "condition", "constraint": {"predicate": "(($_self.isSignlessInteger(1))) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "true_value", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "false_value", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.shift_left", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.sexti", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.ceildivi_signed", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.divi_signed", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.floordivi_signed", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.remi_signed", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.shift_right_signed", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.splat", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "aggregate", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((true))) || (((($_self.isa<::mlir::TensorType>())) && ((true))) && (($_self.cast<::mlir::ShapedType>().hasStaticShape())))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()($aggregate.getType().cast<ShapedType>().getElementType(), $input.getType()))"}], "hasVerifier": true, "operands": [{"name": "input", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || (($_self.isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.subf", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::FloatType>())) || ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || ((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>())))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.subi", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.switch", "numResults": 0, "interfaces": ["::mlir::BranchOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"case_operand_segments": {"predicate": "(($_self.isa<::mlir::DenseIntElementsAttr>())) && (($_self.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(32)))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ElementsAttrBase", "IntElementsAttrBase", "SignlessIntElementsAttr"], "kind": "predicate"}, "case_values": {"predicate": "(($_self.isa<::mlir::DenseIntElementsAttr>())) && ((true))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 3, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 2, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "flag", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "defaultOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}, {"name": "caseOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 2}, {"name": "std.trunci", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.uitofp", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait", "::mlir::CastOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "out", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultShape", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "in", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.divi_unsigned", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.remi_unsigned", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.shift_right_unsigned", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.xor", "numResults": 1, "interfaces": ["::mlir::VectorUnrollOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "std.zexti", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::VectorUnrollOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "std", "traits": [{"name": "::mlir::OpTrait::Elementwise", "kind": "native"}, {"name": "::mlir::OpTrait::Scalarizable", "kind": "native"}, {"name": "::mlir::OpTrait::Vectorizable", "kind": "native"}, {"name": "::mlir::OpTrait::Tensorizable", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "(($_self.isSignlessInteger())) || (($_self.isa<::mlir::IndexType>())) || ((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || ((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))))", "superclass": ["Constraint", "TypeConstraint"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [{"name": "gpu.all_reduce", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {"op": {"predicate": "(($_self.isa<::mlir::StringAttr>())) && ((($_self.cast<::mlir::StringAttr>().getValue() == \"add\")) || (($_self.cast<::mlir::StringAttr>().getValue() == \"and\")) || (($_self.cast<::mlir::StringAttr>().getValue() == \"max\")) || (($_self.cast<::mlir::StringAttr>().getValue() == \"min\")) || (($_self.cast<::mlir::StringAttr>().getValue() == \"mul\")) || (($_self.cast<::mlir::StringAttr>().getValue() == \"or\")) || (($_self.cast<::mlir::StringAttr>().getValue() == \"xor\")))", "superclass": ["Constraint", "AttrConstraint", "Attr", "OptionalAttr"], "kind": "predicate"}}, "numOperands": 1, "results": [{"name": "", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "gpu", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::IsIsolatedFromAbove", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "gpu.alloc", "numResults": 2, "interfaces": ["::mlir::gpu::AsyncOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "memref", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "asyncToken", "constraint": {"kind": "optional", "baseType": {"predicate": "($_self.isa<::mlir::gpu::AsyncTokenType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 3, "dialect": "gpu", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "asyncDependencies", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::gpu::AsyncTokenType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}}, {"name": "dynamicSizes", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "symbolOperands", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "gpu.barrier", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "gpu", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "gpu.block_dim", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"dimension": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "gpu", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "gpu.block_id", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"dimension": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "gpu", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "gpu.dealloc", "numResults": 1, "interfaces": ["::mlir::gpu::AsyncOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "asyncToken", "constraint": {"kind": "optional", "baseType": {"predicate": "($_self.isa<::mlir::gpu::AsyncTokenType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "gpu", "traits": [], "hasVerifier": false, "operands": [{"name": "asyncDependencies", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::gpu::AsyncTokenType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}}, {"name": "memref", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "gpu.func", "numResults": 0, "interfaces": ["::mlir::SymbolOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "gpu", "traits": [{"name": "::mlir::OpTrait::HasParent<GPUModuleOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::AutomaticAllocationScope", "kind": "native"}, {"name": "::mlir::OpTrait::FunctionLike", "kind": "native"}, {"name": "::mlir::OpTrait::IsIsolatedFromAbove", "kind": "native"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "gpu.module", "numResults": 0, "interfaces": ["::mlir::DataLayoutOpInterface::Trait", "::mlir::SymbolOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "gpu", "traits": [{"name": "::mlir::HasDefaultDLTIDataLayout", "kind": "native"}, {"name": "::mlir::OpTrait::IsIsolatedFromAbove", "kind": "native"}, {"name": "::mlir::OpTrait::SymbolTable", "kind": "native"}, {"name": "::mlir::OpTrait::SingleBlockImplicitTerminator<ModuleEndOp>::Impl", "kind": "native"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "gpu.grid_dim", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"dimension": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "gpu", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "gpu.host_register", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "gpu", "traits": [], "hasVerifier": false, "operands": [{"name": "value", "constraint": {"predicate": "(($_self.isa<::mlir::UnrankedMemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "UnrankedMemRefOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "gpu.launch_func", "numResults": 1, "interfaces": ["::mlir::gpu::AsyncOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"kernel": {"predicate": "($_self.isa<::mlir::SymbolRefAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 9, "results": [{"name": "asyncToken", "constraint": {"kind": "optional", "baseType": {"predicate": "($_self.isa<::mlir::gpu::AsyncTokenType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 3, "dialect": "gpu", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "asyncDependencies", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::gpu::AsyncTokenType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}}, {"name": "gridSizeX", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "gridSizeY", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "gridSizeZ", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "blockSizeX", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "blockSizeY", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "blockSizeZ", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "dynamicSharedMemorySize", "constraint": {"kind": "optional", "baseType": {"kind": "integer", "bitwidth": 32}}}, {"name": "operands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "gpu.launch", "numResults": 0, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {}, "numOperands": 7, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "gpu", "traits": [], "hasVerifier": true, "operands": [{"name": "gridSizeX", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "gridSizeY", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "gridSizeZ", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "blockSizeX", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "blockSizeY", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "blockSizeZ", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "dynamicSharedMemorySize", "constraint": {"kind": "optional", "baseType": {"kind": "integer", "bitwidth": 32}}}], "numSuccessors": 0}, {"name": "gpu.memcpy", "numResults": 1, "interfaces": ["::mlir::gpu::AsyncOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "asyncToken", "constraint": {"kind": "optional", "baseType": {"predicate": "($_self.isa<::mlir::gpu::AsyncTokenType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "gpu", "traits": [], "hasVerifier": true, "operands": [{"name": "asyncDependencies", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::gpu::AsyncTokenType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}}, {"name": "dst", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "src", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "gpu.memset", "numResults": 1, "interfaces": ["::mlir::gpu::AsyncOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "asyncToken", "constraint": {"kind": "optional", "baseType": {"predicate": "($_self.isa<::mlir::gpu::AsyncTokenType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "gpu", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({getElementTypeOrSelf($dst), getElementTypeOrSelf($value)})))"}], "hasVerifier": false, "operands": [{"name": "asyncDependencies", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::gpu::AsyncTokenType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}}, {"name": "dst", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "value", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "gpu.module_end", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "gpu", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}, {"name": "::mlir::OpTrait::HasParent<GPUModuleOp>::Impl", "kind": "native"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "gpu.num_subgroups", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "gpu", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "gpu.return", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "gpu", "traits": [{"name": "::mlir::OpTrait::HasParent<GPUFuncOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "gpu.shuffle", "numResults": 2, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"mode": {"predicate": "(($_self.isa<::mlir::StringAttr>())) && (($_self.cast<::mlir::StringAttr>().getValue() == \"xor\"))", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "StrEnumAttr"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "valid", "constraint": {"kind": "integer", "bitwidth": 1}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "gpu", "traits": [], "hasVerifier": true, "operands": [{"name": "value", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "offset", "constraint": {"kind": "integer", "bitwidth": 32}}, {"name": "width", "constraint": {"kind": "integer", "bitwidth": 32}}], "numSuccessors": 0}, {"name": "gpu.subgroup_id", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "gpu", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "gpu.subgroup_mma_compute", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "($_self.isa<::mlir::gpu::MMAMatrixType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "gpu", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$opC.getType(), $res.getType()})))"}], "hasVerifier": true, "operands": [{"name": "opA", "constraint": {"predicate": "(($_self.isa<::mlir::gpu::MMAMatrixType>())) && (($_self.cast<::mlir::gpu::MMAMatrixType>().getElementType().isF16()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "MMAMatrixOf"], "kind": "predicate"}}, {"name": "opB", "constraint": {"predicate": "(($_self.isa<::mlir::gpu::MMAMatrixType>())) && (($_self.cast<::mlir::gpu::MMAMatrixType>().getElementType().isF16()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "MMAMatrixOf"], "kind": "predicate"}}, {"name": "opC", "constraint": {"predicate": "(($_self.isa<::mlir::gpu::MMAMatrixType>())) && ((($_self.cast<::mlir::gpu::MMAMatrixType>().getElementType().isF16())) || (($_self.cast<::mlir::gpu::MMAMatrixType>().getElementType().isF32())))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "MMAMatrixOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "gpu.subgroup_mma_constant_matrix", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "res", "constraint": {"predicate": "($_self.isa<::mlir::gpu::MMAMatrixType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "gpu", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()($res.getType().cast<gpu::MMAMatrixType>().getElementType(), $value.getType()))"}], "hasVerifier": false, "operands": [{"name": "value", "constraint": {"predicate": "(($_self.isF16())) || (($_self.isF32()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "gpu.subgroup_mma_load_matrix", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"leadDimension": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isa<::mlir::IndexType>()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "($_self.isa<::mlir::gpu::MMAMatrixType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "gpu", "traits": [], "hasVerifier": true, "operands": [{"name": "srcMemref", "constraint": {"predicate": "((($_self.isa<::mlir::MemRefType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)))", "superclass": ["Constraint", "TypeConstraint", "Type", "MemRefRankOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "gpu.subgroup_mma_store_matrix", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"leadDimension": {"predicate": "(($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isa<::mlir::IndexType>()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "TypedAttrBase"], "kind": "predicate"}}, "numOperands": 3, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "gpu", "traits": [], "hasVerifier": true, "operands": [{"name": "src", "constraint": {"predicate": "(($_self.isa<::mlir::gpu::MMAMatrixType>())) && ((($_self.cast<::mlir::gpu::MMAMatrixType>().getElementType().isF16())) || (($_self.cast<::mlir::gpu::MMAMatrixType>().getElementType().isF32())))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "MMAMatrixOf"], "kind": "predicate"}}, {"name": "dstMemref", "constraint": {"predicate": "((($_self.isa<::mlir::MemRefType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isF32())))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 2)))", "superclass": ["Constraint", "TypeConstraint", "Type", "MemRefRankOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "gpu.subgroup_size", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "gpu", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "gpu.terminator", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "gpu", "traits": [{"name": "::mlir::OpTrait::HasParent<LaunchOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "gpu.thread_id", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {"dimension": {"predicate": "($_self.isa<::mlir::StringAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "StringBasedAttr"], "kind": "predicate"}}, "numOperands": 0, "results": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "gpu", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}, {"name": "gpu.wait", "numResults": 1, "interfaces": ["::mlir::gpu::AsyncOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "asyncToken", "constraint": {"kind": "optional", "baseType": {"predicate": "($_self.isa<::mlir::gpu::AsyncTokenType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "gpu", "traits": [], "hasVerifier": false, "operands": [{"name": "asyncDependencies", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::gpu::AsyncTokenType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "gpu.yield", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "gpu", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "values", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [{"name": "complex.abs", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::FloatType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "complex", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()($complex.getType().cast<ComplexType>().getElementType(), $result.getType()))"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "complex", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "complex.add", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "complex", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "complex.create", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "complex", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "complex", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$real.getType(), $imaginary.getType()})))"}, {"kind": "pred", "pred": "(std::equal_to<>()($complex.getType().cast<ComplexType>().getElementType(), $real.getType()))"}, {"kind": "pred", "pred": "(std::equal_to<>()($complex.getType().cast<ComplexType>().getElementType(), $imaginary.getType()))"}], "hasVerifier": false, "operands": [{"name": "real", "constraint": {"predicate": "($_self.isa<::mlir::FloatType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "imaginary", "constraint": {"predicate": "($_self.isa<::mlir::FloatType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "complex.div", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "complex", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "complex.eq", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"kind": "integer", "bitwidth": 1}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "complex", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$lhs.getType(), $rhs.getType()})))"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "complex.exp", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "complex", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "complex", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "complex.im", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "imaginary", "constraint": {"predicate": "($_self.isa<::mlir::FloatType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "complex", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()($complex.getType().cast<ComplexType>().getElementType(), $imaginary.getType()))"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "complex", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "complex.log1p", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "complex", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "complex", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "complex.log", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "complex", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "complex", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "complex.mul", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "complex", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "complex.neg", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "complex", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "complex", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "complex.neq", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"kind": "integer", "bitwidth": 1}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "complex", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$lhs.getType(), $rhs.getType()})))"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "complex.re", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "real", "constraint": {"predicate": "($_self.isa<::mlir::FloatType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "complex", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()($complex.getType().cast<ComplexType>().getElementType(), $real.getType()))"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "complex", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "complex.sign", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "complex", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "complex", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "complex.sub", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "complex", "traits": [{"name": "::mlir::OpTrait::SameOperandsAndResultType", "kind": "native"}, {"name": "::mlir::OpTrait::Elementwise", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::ComplexType>())) && (($_self.cast<::mlir::ComplexType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "SameBuildabilityAs", "Complex"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [], "types": [{"name": "Async_CoroHandleType", "cppName": "::mlir::Type", "numParameters": 0, "dialect": "async", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Async_CoroIdType", "cppName": "::mlir::Type", "numParameters": 0, "dialect": "async", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Async_CoroStateType", "cppName": "::mlir::Type", "numParameters": 0, "dialect": "async", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Async_GroupType", "cppName": "::mlir::Type", "numParameters": 0, "dialect": "async", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Async_TokenType", "cppName": "::mlir::Type", "numParameters": 0, "dialect": "async", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Async_ValueType", "cppName": "::mlir::Type", "numParameters": 1, "dialect": "async", "parameters": [{"name": "valueType", "cppType": "Type"}], "hasVerifier": false, "traits": [], "interfaces": []}], "attrs": []}, {"ops": [{"name": "async.add_to_group", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "rank", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::async::ValueType>())) || (($_self.isa<::mlir::async::TokenType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "group", "constraint": {"name": "Async_GroupType", "dialect": "async", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "async.await_all", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"name": "Async_GroupType", "dialect": "async", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "async.await", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"kind": "optional", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [], "hasVerifier": true, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::async::ValueType>())) || (($_self.isa<::mlir::async::TokenType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "async.coro.begin", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "handle", "constraint": {"name": "Async_CoroHandleType", "dialect": "async", "kind": "typeDef"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [], "hasVerifier": false, "operands": [{"name": "id", "constraint": {"name": "Async_CoroIdType", "dialect": "async", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "async.coro.end", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [], "hasVerifier": false, "operands": [{"name": "handle", "constraint": {"name": "Async_CoroHandleType", "dialect": "async", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "async.coro.free", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [], "hasVerifier": false, "operands": [{"name": "id", "constraint": {"name": "Async_CoroIdType", "dialect": "async", "kind": "typeDef"}}, {"name": "handle", "constraint": {"name": "Async_CoroHandleType", "dialect": "async", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "async.coro.id", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "id", "constraint": {"name": "Async_CoroIdType", "dialect": "async", "kind": "typeDef"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "async.coro.save", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "state", "constraint": {"name": "Async_CoroStateType", "dialect": "async", "kind": "typeDef"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [], "hasVerifier": false, "operands": [{"name": "handle", "constraint": {"name": "Async_CoroHandleType", "dialect": "async", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "async.coro.suspend", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [{"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "state", "constraint": {"name": "Async_CoroStateType", "dialect": "async", "kind": "typeDef"}}], "numSuccessors": 3}, {"name": "async.create_group", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"name": "Async_GroupType", "dialect": "async", "kind": "typeDef"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [], "hasVerifier": false, "operands": [{"name": "size", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "async.execute", "numResults": 2, "interfaces": ["::mlir::RegionBranchOpInterface::Trait"], "hasAssemblyFormat": false, "numRegions": 1, "attributes": {}, "numOperands": 2, "results": [{"name": "token", "constraint": {"name": "Async_TokenType", "dialect": "async", "kind": "typeDef"}}, {"name": "results", "constraint": {"kind": "variadic", "baseType": {"name": "Async_ValueType", "dialect": "async", "kind": "typeDef"}}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 2, "dialect": "async", "traits": [{"name": "::mlir::OpTrait::SingleBlockImplicitTerminator<YieldOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "dependencies", "constraint": {"kind": "variadic", "baseType": {"name": "Async_TokenType", "dialect": "async", "kind": "typeDef"}}}, {"name": "operands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(($_self.isa<::mlir::async::ValueType>())) || (($_self.isa<::mlir::async::TokenType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "async.runtime.add_ref", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"count": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))) && (($_self.cast<IntegerAttr>().getValue().isStrictlyPositive()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::async::ValueType>())) || (($_self.isa<::mlir::async::TokenType>())) || (($_self.isa<::mlir::async::GroupType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "async.runtime.add_to_group", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "rank", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::async::ValueType>())) || (($_self.isa<::mlir::async::TokenType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "group", "constraint": {"name": "Async_GroupType", "dialect": "async", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "async.runtime.await_and_resume", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::async::ValueType>())) || (($_self.isa<::mlir::async::TokenType>())) || (($_self.isa<::mlir::async::GroupType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}, {"name": "handle", "constraint": {"name": "Async_CoroHandleType", "dialect": "async", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "async.runtime.await", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::async::ValueType>())) || (($_self.isa<::mlir::async::TokenType>())) || (($_self.isa<::mlir::async::GroupType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "async.runtime.create_group", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"name": "Async_GroupType", "dialect": "async", "kind": "typeDef"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [], "hasVerifier": false, "operands": [{"name": "size", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "async.runtime.create", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::async::ValueType>())) || (($_self.isa<::mlir::async::TokenType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "async.runtime.drop_ref", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"count": {"predicate": "((($_self.isa<::mlir::IntegerAttr>())) && (($_self.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64)))) && (($_self.cast<IntegerAttr>().getValue().isStrictlyPositive()))", "superclass": ["Constraint", "AttrConstraint", "Attr", "Confined"], "kind": "predicate"}}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::async::ValueType>())) || (($_self.isa<::mlir::async::TokenType>())) || (($_self.isa<::mlir::async::GroupType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "async.runtime.is_error", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "is_error", "constraint": {"kind": "integer", "bitwidth": 1}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::async::ValueType>())) || (($_self.isa<::mlir::async::TokenType>())) || (($_self.isa<::mlir::async::GroupType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "async.runtime.load", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()($storage.getType().cast<ValueType>().getValueType(), $result.getType()))"}], "hasVerifier": false, "operands": [{"name": "storage", "constraint": {"name": "Async_ValueType", "dialect": "async", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "async.runtime.resume", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [], "hasVerifier": false, "operands": [{"name": "handle", "constraint": {"name": "Async_CoroHandleType", "dialect": "async", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "async.runtime.set_available", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::async::ValueType>())) || (($_self.isa<::mlir::async::TokenType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "async.runtime.set_error", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [], "hasVerifier": false, "operands": [{"name": "operand", "constraint": {"predicate": "(($_self.isa<::mlir::async::ValueType>())) || (($_self.isa<::mlir::async::TokenType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "AnyTypeOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "async.runtime.store", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "async", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()($storage.getType().cast<ValueType>().getValueType(), $value.getType()))"}], "hasVerifier": false, "operands": [{"name": "value", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "storage", "constraint": {"name": "Async_ValueType", "dialect": "async", "kind": "typeDef"}}], "numSuccessors": 0}, {"name": "async.yield", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::RegionBranchTerminatorOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "async", "traits": [{"name": "::mlir::OpTrait::HasParent<ExecuteOp>::Impl", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "operands", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}], "types": [{"name": "Async_CoroHandleType", "cppName": "::mlir::Type", "numParameters": 0, "dialect": "async", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Async_CoroIdType", "cppName": "::mlir::Type", "numParameters": 0, "dialect": "async", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Async_CoroStateType", "cppName": "::mlir::Type", "numParameters": 0, "dialect": "async", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Async_GroupType", "cppName": "::mlir::Type", "numParameters": 0, "dialect": "async", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Async_TokenType", "cppName": "::mlir::Type", "numParameters": 0, "dialect": "async", "parameters": [], "hasVerifier": false, "traits": [], "interfaces": []}, {"name": "Async_ValueType", "cppName": "::mlir::Type", "numParameters": 1, "dialect": "async", "parameters": [{"name": "valueType", "cppType": "Type"}], "hasVerifier": false, "traits": [], "interfaces": []}], "attrs": []}, {"ops": [], "types": [], "attrs": []}, {"ops": [{"name": "tensor.cast", "numResults": 1, "interfaces": ["::mlir::CastOpInterface::Trait", "::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "dest", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tensor", "traits": [], "hasVerifier": false, "operands": [{"name": "source", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tensor.dim", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::InferTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tensor", "traits": [], "hasVerifier": true, "operands": [{"name": "source", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "index", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tensor.extract", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "tensor", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()($tensor.getType().cast<ShapedType>().getElementType(), $result.getType()))"}], "hasVerifier": true, "operands": [{"name": "tensor", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "tensor.extract_slice", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::ReifyRankedShapedTypeOpInterface::Trait", "::mlir::OffsetSizeAndStrideOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"static_offsets": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "static_sizes": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "static_strides": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 4, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().hasRank()))) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "RankedTensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 3, "dialect": "tensor", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "source", "constraint": {"predicate": "((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().hasRank()))) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "RankedTensorOf"], "kind": "predicate"}}, {"name": "offsets", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "sizes", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "strides", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "tensor.from_elements", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isa<::mlir::TensorType>())) && ((true))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "TensorRankOf", "1DTensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "tensor", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()(SmallVector<Type, 2>($result.getType().cast<ShapedType>().getDimSize(0), $result.getType().cast<ShapedType>().getElementType()), $elements.getType()))"}], "hasVerifier": false, "operands": [{"name": "elements", "constraint": {"kind": "variadic", "baseType": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "tensor.generate", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 1, "attributes": {}, "numOperands": 1, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().hasRank()))) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "RankedTensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "tensor", "traits": [{"name": "::mlir::OpTrait::HasRecursiveSideEffects", "kind": "native"}, {"name": "::mlir::OpTrait::SingleBlockImplicitTerminator<mlir::tensor::YieldOp>::Impl", "kind": "native"}], "hasVerifier": true, "operands": [{"name": "dynamicExtents", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "tensor.insert", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "tensor", "traits": [{"kind": "pred", "pred": "(std::equal_to<>()($dest.getType().cast<ShapedType>(), $result.getType()))"}, {"kind": "pred", "pred": "(std::equal_to<>()($dest.getType().cast<ShapedType>().getElementType(), $scalar.getType()))"}], "hasVerifier": true, "operands": [{"name": "scalar", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "dest", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "tensor.insert_slice", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait", "::mlir::OffsetSizeAndStrideOpInterface::Trait", "::mlir::ReifyRankedShapedTypeOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"static_offsets": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "static_sizes": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}, "static_strides": {"predicate": "(($_self.isa<::mlir::ArrayAttr>())) && (::llvm::all_of($_self.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))", "superclass": ["Constraint", "AttrConstraint", "Attr", "ArrayAttrBase", "TypedArrayAttrBase"], "kind": "predicate"}}, "numOperands": 5, "results": [{"name": "result", "constraint": {"predicate": "((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().hasRank()))) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "RankedTensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 3, "dialect": "tensor", "traits": [{"name": "::mlir::OpTrait::AttrSizedOperandSegments", "kind": "native"}, {"kind": "pred", "pred": "(std::equal_to<>()($dest.getType(), $result.getType()))"}], "hasVerifier": false, "operands": [{"name": "source", "constraint": {"predicate": "((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().hasRank()))) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "RankedTensorOf"], "kind": "predicate"}}, {"name": "dest", "constraint": {"predicate": "((($_self.isa<::mlir::TensorType>())) && (($_self.cast<::mlir::ShapedType>().hasRank()))) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "RankedTensorOf"], "kind": "predicate"}}, {"name": "offsets", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "sizes", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "strides", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "tensor.reshape", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tensor", "traits": [], "hasVerifier": true, "operands": [{"name": "source", "constraint": {"predicate": "(($_self.isa<::mlir::TensorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "TensorOf"], "kind": "predicate"}}, {"name": "shape", "constraint": {"predicate": "((($_self.isa<::mlir::TensorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || (($_self.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) && ((($_self.cast<::mlir::ShapedType>().hasRank())) && (($_self.cast<::mlir::ShapedType>().getRank()                          == 1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "TensorRankOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "tensor.yield", "numResults": 0, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 1, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "tensor", "traits": [{"name": "::mlir::OpTrait::ReturnLike", "kind": "native"}, {"name": "::mlir::OpTrait::IsTerminator", "kind": "native"}, {"name": "::mlir::OpTrait::HasParent<::mlir::tensor::GenerateOp>::Impl", "kind": "native"}], "hasVerifier": false, "operands": [{"name": "value", "constraint": {"predicate": "(true)", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}], "types": [], "attrs": []}, {"ops": [{"name": "arm_sve.addf", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "dst", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType(), $dst.getType()})))"}], "hasVerifier": false, "operands": [{"name": "src1", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.addi", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "dst", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType(), $dst.getType()})))"}], "hasVerifier": false, "operands": [{"name": "src1", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.cmpf", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"predicate": {"predicate": "($_self.isa<::mlir::CmpFPredicateAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I64EnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"kind": "pred", "pred": "(std::equal_to<>()(getI1SameShape($lhs.getType()), $result.getType()))"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.cmpi", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"predicate": {"predicate": "($_self.isa<::mlir::CmpIPredicateAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr", "EnumAttrInfo", "IntEnumAttr", "I64EnumAttr"], "kind": "predicate"}}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"name": "::mlir::OpTrait::SameTypeOperands", "kind": "native"}, {"kind": "pred", "pred": "(std::equal_to<>()(getI1SameShape($lhs.getType()), $result.getType()))"}], "hasVerifier": false, "operands": [{"name": "lhs", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.divf", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "dst", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType(), $dst.getType()})))"}], "hasVerifier": false, "operands": [{"name": "src1", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.load", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "result", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [], "hasVerifier": false, "operands": [{"name": "base", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "index", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.intr.fadd", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.masked.addf", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType(), $res.getType()})))"}, {"kind": "pred", "pred": "(std::equal_to<>()(getI1SameShape($src1.getType()), $mask.getType()))"}], "hasVerifier": false, "operands": [{"name": "mask", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src1", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.intr.add", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.masked.addi", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType(), $res.getType()})))"}, {"kind": "pred", "pred": "(std::equal_to<>()(getI1SameShape($src1.getType()), $mask.getType()))"}], "hasVerifier": false, "operands": [{"name": "mask", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src1", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.intr.fdiv", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.masked.divf", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType(), $res.getType()})))"}, {"kind": "pred", "pred": "(std::equal_to<>()(getI1SameShape($src1.getType()), $mask.getType()))"}], "hasVerifier": false, "operands": [{"name": "mask", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src1", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.intr.fmul", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.masked.mulf", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType(), $res.getType()})))"}, {"kind": "pred", "pred": "(std::equal_to<>()(getI1SameShape($src1.getType()), $mask.getType()))"}], "hasVerifier": false, "operands": [{"name": "mask", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src1", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.intr.mul", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.masked.muli", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType(), $res.getType()})))"}, {"kind": "pred", "pred": "(std::equal_to<>()(getI1SameShape($src1.getType()), $mask.getType()))"}], "hasVerifier": false, "operands": [{"name": "mask", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src1", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.intr.sdiv", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.masked.divi_signed", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType(), $res.getType()})))"}, {"kind": "pred", "pred": "(std::equal_to<>()(getI1SameShape($src1.getType()), $mask.getType()))"}], "hasVerifier": false, "operands": [{"name": "mask", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src1", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.intr.fsub", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.masked.subf", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType(), $res.getType()})))"}, {"kind": "pred", "pred": "(std::equal_to<>()(getI1SameShape($src1.getType()), $mask.getType()))"}], "hasVerifier": false, "operands": [{"name": "mask", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src1", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.intr.sub", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.masked.subi", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType(), $res.getType()})))"}, {"kind": "pred", "pred": "(std::equal_to<>()(getI1SameShape($src1.getType()), $mask.getType()))"}], "hasVerifier": false, "operands": [{"name": "mask", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src1", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.intr.udiv", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.masked.divi_unsigned", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType(), $res.getType()})))"}, {"kind": "pred", "pred": "(std::equal_to<>()(getI1SameShape($src1.getType()), $mask.getType()))"}], "hasVerifier": false, "operands": [{"name": "mask", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(1)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src1", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.mulf", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "dst", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType(), $dst.getType()})))"}], "hasVerifier": false, "operands": [{"name": "src1", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.muli", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "dst", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"name": "::mlir::OpTrait::IsCommutative", "kind": "native"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType(), $dst.getType()})))"}], "hasVerifier": false, "operands": [{"name": "src1", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.divi_signed", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "dst", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType(), $dst.getType()})))"}], "hasVerifier": false, "operands": [{"name": "src1", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.store", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [], "hasVerifier": false, "operands": [{"name": "base", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "index", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}, {"name": "value", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.subf", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "dst", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType(), $dst.getType()})))"}], "hasVerifier": false, "operands": [{"name": "src1", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isa<::mlir::FloatType>()))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.subi", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "dst", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType(), $dst.getType()})))"}], "hasVerifier": false, "operands": [{"name": "src1", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.divi_unsigned", "numResults": 1, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "dst", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType(), $dst.getType()})))"}], "hasVerifier": false, "operands": [{"name": "src1", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "(($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ScalableVectorOf"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.intr.sdot", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.sdot", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "dst", "constraint": {"predicate": "((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))) && ((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 4)) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 2))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ScalableVectorOfLengthAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType()})))"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$acc.getType(), $dst.getType()})))"}], "hasVerifier": false, "operands": [{"name": "acc", "constraint": {"predicate": "((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))) && ((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 4)) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 2))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ScalableVectorOfLengthAndType"], "kind": "predicate"}}, {"name": "src1", "constraint": {"predicate": "((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))))) && ((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 16)) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ScalableVectorOfLengthAndType"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))))) && ((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 16)) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ScalableVectorOfLengthAndType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.intr.smmla", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.smmla", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "dst", "constraint": {"predicate": "((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32)))) && ((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 4)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ScalableVectorOfLengthAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType()})))"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$acc.getType(), $dst.getType()})))"}], "hasVerifier": false, "operands": [{"name": "acc", "constraint": {"predicate": "((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32)))) && ((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 4)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ScalableVectorOfLengthAndType"], "kind": "predicate"}}, {"name": "src1", "constraint": {"predicate": "((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8)))) && ((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 16)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ScalableVectorOfLengthAndType"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8)))) && ((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 16)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ScalableVectorOfLengthAndType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.intr.udot", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.udot", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "dst", "constraint": {"predicate": "((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))) && ((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 4)) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 2))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ScalableVectorOfLengthAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType()})))"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$acc.getType(), $dst.getType()})))"}], "hasVerifier": false, "operands": [{"name": "acc", "constraint": {"predicate": "((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(64))))) && ((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 4)) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 2))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ScalableVectorOfLengthAndType"], "kind": "predicate"}}, {"name": "src1", "constraint": {"predicate": "((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))))) && ((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 16)) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ScalableVectorOfLengthAndType"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8))) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(16))))) && ((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && ((($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 16)) || (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 8))))", "superclass": ["Constraint", "TypeConstraint", "Type", "ScalableVectorOfLengthAndType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.intr.ummla", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMScalableVectorType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.ummla", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "dst", "constraint": {"predicate": "((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32)))) && ((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 4)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ScalableVectorOfLengthAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$src1.getType(), $src2.getType()})))"}, {"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$acc.getType(), $dst.getType()})))"}], "hasVerifier": false, "operands": [{"name": "acc", "constraint": {"predicate": "((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(32)))) && ((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 4)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ScalableVectorOfLengthAndType"], "kind": "predicate"}}, {"name": "src1", "constraint": {"predicate": "((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8)))) && ((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 16)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ScalableVectorOfLengthAndType"], "kind": "predicate"}}, {"name": "src2", "constraint": {"predicate": "((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getElementType().isSignlessInteger(8)))) && ((($_self.isa<::mlir::arm_sve::ScalableVectorType>())) && (($_self.cast<::mlir::arm_sve::ScalableVectorType>().getNumElements() == 16)))", "superclass": ["Constraint", "TypeConstraint", "Type", "ScalableVectorOfLengthAndType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "arm_sve.vscale", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}, {"name": "arm_sve.vector_scale", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "arm_sve", "traits": [], "hasVerifier": false, "operands": [], "numSuccessors": 0}], "types": [{"name": "ScalableVectorType", "cppName": "::mlir::Type", "numParameters": 2, "dialect": "arm_sve", "parameters": [{"name": "shape", "cppType": "::llvm::ArrayRef<int64_t>"}, {"name": "elementType", "cppType": "Type"}], "hasVerifier": false, "traits": [], "interfaces": []}], "attrs": []}, {"ops": [{"name": "amx.tdpbf16ps", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 6, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "amx", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "amx.tdpbssd", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 6, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "amx", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "amx.tdpbsud", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 6, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "amx", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "amx.tdpbusd", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 6, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "amx", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "amx.tdpbuud", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 6, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "amx", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "amx.tileloadd64", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 4, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "amx", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMPointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "amx.tilestored64", "numResults": 0, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 5, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "amx", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::LLVM::LLVMPointerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "amx.tilezero", "numResults": 1, "interfaces": [], "hasAssemblyFormat": false, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "(::mlir::LLVM::isCompatibleType($_self))", "superclass": ["Constraint", "TypeConstraint", "Type", "DialectType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "amx", "traits": [], "hasVerifier": false, "operands": [{"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}, {"name": "", "constraint": {"predicate": "($_self.isa<::mlir::IntegerType>())", "superclass": ["Constraint", "TypeConstraint", "Type"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "amx.tile_load", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 2, "results": [{"name": "res", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 2)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "amx", "traits": [], "hasVerifier": true, "operands": [{"name": "base", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}], "numSuccessors": 0}, {"name": "amx.tile_mulf", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16())))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 2)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "amx", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$acc.getType(), $res.getType()})))"}], "hasVerifier": true, "operands": [{"name": "lhs", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16())))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 2)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16())))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 2)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}, {"name": "acc", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16())))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 2)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "amx.tile_muli", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {"isZextRhs": {"predicate": "($_self.isa<::mlir::UnitAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}, "isZextLhs": {"predicate": "($_self.isa<::mlir::UnitAttr>())", "superclass": ["Constraint", "AttrConstraint", "Attr"], "kind": "predicate"}}, "numOperands": 3, "results": [{"name": "res", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 2)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "amx", "traits": [{"kind": "pred", "pred": "(::llvm::is_splat(::llvm::makeArrayRef({$acc.getType(), $res.getType()})))"}], "hasVerifier": true, "operands": [{"name": "lhs", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 2)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}, {"name": "rhs", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 2)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}, {"name": "acc", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 2)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "amx.tile_store", "numResults": 0, "interfaces": [], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 3, "results": [], "hasNoVariadicRegions": true, "numVariableLengthOperands": 1, "dialect": "amx", "traits": [], "hasVerifier": true, "operands": [{"name": "base", "constraint": {"predicate": "(($_self.isa<::mlir::MemRefType>())) && ((true))", "superclass": ["Constraint", "TypeConstraint", "Type", "ContainerType", "ShapedContainerType", "MemRefOf"], "kind": "predicate"}}, {"name": "indices", "constraint": {"kind": "variadic", "baseType": {"predicate": "($_self.isa<::mlir::IndexType>())", "superclass": ["Constraint", "TypeConstraint", "Type", "BuildableType"], "kind": "predicate"}}}, {"name": "val", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 2)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}], "numSuccessors": 0}, {"name": "amx.tile_zero", "numResults": 1, "interfaces": ["::mlir::MemoryEffectOpInterface::Trait"], "hasAssemblyFormat": true, "numRegions": 0, "attributes": {}, "numOperands": 0, "results": [{"name": "res", "constraint": {"predicate": "((($_self.isa<::mlir::VectorType>())) && ((($_self.cast<::mlir::ShapedType>().getElementType().isF32())) || (($_self.cast<::mlir::ShapedType>().getElementType().isBF16())) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || (($_self.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))))) && ((($_self.isa<::mlir::VectorType>())) && (($_self.cast<::mlir::VectorType>().getRank()                            == 2)))", "superclass": ["Constraint", "TypeConstraint", "Type", "VectorOfRankAndType"], "kind": "predicate"}}], "hasNoVariadicRegions": true, "numVariableLengthOperands": 0, "dialect": "amx", "traits": [], "hasVerifier": true, "operands": [], "numSuccessors": 0}], "types": [], "attrs": []}]